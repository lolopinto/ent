{{ reserveImport "context"}} 

{{ reserveImport "github.com/lolopinto/ent/ent" }}
{{ reserveImport "github.com/lolopinto/ent/ent/actions" }}
{{ reserveImport "github.com/lolopinto/ent/ent/viewer" }}

{{$action := .Action -}}
{{$nodeInfo := nodeInfo $action -}}

{{with .CodePath -}}

	{{reserveImport .PathToModels}}
  {{reserveImport .PathToConfigs}}

  {{$builderPath := .AppendPathToModels $nodeInfo.NodeInstance }}
  {{reserveImport $builderPath "builder"}}

{{end -}}

{{$actionName := actionName $action}}

{{$builderName := printf "%sMutationBuilder" $nodeInfo.Node -}}
{{$builderType := printf "*builder.%s" $builderName -}}

{{$nonEntFields := nonEntFields $action}}

type {{$actionName}} struct {
  builder {{$builderType}}
}

{{$actionMethodName := actionMethodName $action}}

// {{$actionMethodName}}FromContext is the factory method to get an ...
func {{$actionMethodName}}FromContext( {{actionMethodContextArgs $action}}) *{{$actionName}} {
  v, err := viewer.ForContext(ctx)
	if err != nil {
    panic("tried to perform mutation without a viewer")
	}
  return {{$actionMethodName}}({{argsToViewerMethod $action}})
}

// {{$actionMethodName}} is the factory method to get an ...
func {{$actionMethodName}}( {{actionMethodArgs $action}}) *{{$actionName}} {
  action := &{{$actionName}}{}
  {{/* TODO the best long term thing here probably is to push this into the builder and have EventMutationBuilder use an EdgeGroupMutationBuilder for example instead of an EntMutationBuilder however need to make it work for multiple group statuses in the same mutation so doing it this way instead for now */ -}}
  builder := builder.NewMutationBuilder(
    viewer,
    {{writeOperation $action}},
    action.getFieldMap(),
    {{ if $action.MutatingExistingObject -}}
      actions.ExistingEnt({{$nodeInfo.NodeInstance}}),
    {{ end -}}
  )
  action.builder = builder
  return action
}

func (action *{{$actionName}}) GetBuilder() ent.MutationBuilder {
  return action.builder
}

func (action *{{$actionName}}) GetTypedBuilder() {{$builderType}} {
  return action.builder
}

func (action *{{$actionName}}) GetViewer() viewer.ViewerContext {
  return action.builder.GetViewer()
}

func (action *{{$actionName}}) SetBuilderOnTriggers(triggers []actions.Trigger) error {
	return action.builder.SetTriggers(triggers)
}

func (action *{{$actionName}}) SetBuilderOnObservers(observers []actions.Observer) error {
  return action.builder.SetObservers(observers)
}

func (action *{{$actionName}}) GetChangeset() (ent.Changeset, error) {
  return actions.GetChangeset(action)
}

func (action *{{$actionName}}) Entity() ent.Entity {
  {{ if returnsObjectInstance $action -}}
    return action.builder.Get{{$nodeInfo.Node}}()
  {{ else -}}
    return nil
  {{end -}}
}

func (action *{{$actionName}}) ExistingEnt() ent.Entity {
  return action.builder.ExistingEnt()
}

{{$fields := fields $action}}

{{ range $field := $fields -}}
// {{$field.SetterMethodName}} sets the {{$field.FieldName}} while editing the {{$nodeInfo.Node}} ent 
func (action *{{$actionName}}) {{$field.SetterMethodName}}({{$field.InstanceName}} {{$field.InstanceType}}) *{{$actionName}} {
  action.builder.{{$field.SetterMethodName}}({{$field.InstanceName}})
  return action
}
  {{ if $field.Field.IDField -}}
  // {{$field.SetterMethodName}}Builder sets the {{$field.FieldName}} while editing the {{$nodeInfo.Node}} ent 
  func (action *{{$actionName}}) {{$field.SetterMethodName}}Builder(builder ent.MutationBuilder) *{{$actionName}} {
    action.builder.{{$field.SetterMethodName}}Builder(builder)
    return action
  }

  {{end -}}

{{end -}}

{{ range $field := $nonEntFields -}}
// {{$field.SetterMethodName}} sets the {{$field.FieldName}} while editing the {{$nodeInfo.Node}} ent 
func (action *{{$actionName}}) {{$field.SetterMethodName}}({{$field.InstanceName}} {{$field.InstanceType}}) *{{$actionName}} {
  {{ if $field.IsStatusEnum -}}
    action.builder.SetEnumValue({{$field.InstanceName}})
  {{ end -}}
  {{ if $field.IsGroupID -}}
    action.builder.SetIDValue({{$field.InstanceName}}, {{$field.NodeType}})
  {{ end -}}
  return action
}

{{end -}}

{{ $edges := edges $action}}

{{ range $edge := $edges -}}
// {{$edge.AddMethodName}} adds an instance of {{$edge.Node}} to the {{$edge.EdgeName}} edge while editing the {{$nodeInfo.Node}} ent 
func (action *{{$actionName}}) {{$edge.AddMethodName}}({{$edge.InstanceName}} {{$edge.InstanceType}}) *{{$actionName}} {
  {{/* TODO time and data support later */ -}}  
  {{ if removeEdgeAction $action -}}
    action.builder.{{$edge.RemoveMethodName}}({{$edge.InstanceName}})
  {{else -}}
    action.builder.{{$edge.AddMethodName}}({{$edge.InstanceName}})
  {{end -}}
  return action
}

{{/* TODO rename this correctly for different action types... */}}
// {{$edge.AddMethodName}} adds an instance of {{$edge.Node}}Id to the {{$edge.EdgeName}} edge while editing the {{$nodeInfo.Node}} ent 
func (action *{{$actionName}}) {{$edge.AddMethodName}}ID({{$edge.InstanceName}}ID string) *{{$actionName}} {
  {{/* TODO time and data support later */ -}}  
  {{ if removeEdgeAction $action -}}
    action.builder.{{$edge.RemoveMethodName}}ID({{$edge.InstanceName}}ID)
  {{ else -}}
    action.builder.{{$edge.AddMethodName}}ID({{$edge.InstanceName}}ID)
  {{end -}}
  return action
}
{{end -}}


// getFieldMap returns the fields that could be edited in this mutation
func (action *{{$actionName}}) getFieldMap() ent.ActionFieldMap {
  {{/* TODO ActionFieldMap and MutatingFieldInfo should not be public in ent anymore? */ -}}
  return ent.ActionFieldMap {
    {{ range $field := $fields -}}
      {{$field.QuotedFieldName}}: &ent.MutatingFieldInfo {
        DB: {{$field.QuotedDBName}},
        {{ if createAction $action -}}
          Required: true,
        {{ else -}}
          Required: false,
        {{end -}}
      },
    {{end -}}
  }
}

// Validate returns an error if the current state of the action is not valid
func (action *{{$actionName}}) Validate() error {
  return action.builder.Validate()
}

// Save is the method called to execute this action and save change
func (action * {{$actionName}}) Save() {{saveActionType $action}} {
  {{ if returnsObjectInstance $action -}}
    err := actions.Save(action)
    return action.builder.Get{{$nodeInfo.Node}}(), err
  {{else -}}
    return actions.Save(action)
  {{end -}}
}

var _ actions.Action = &{{$actionName}}{}

