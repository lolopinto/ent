package file

import (
	"bytes"
	"fmt"
	"os/exec"
	"strings"
	"text/template"

	intimports "github.com/lolopinto/ent/internal/imports"
	"github.com/pkg/errors"
	"golang.org/x/tools/imports"
)

type TemplatedBasedFileWriter struct {
	Data              interface{}
	AbsPathToTemplate string
	TemplateName      string
	PathToFile        string
	CreateDirIfNeeded bool
	FormatSource      bool
	FuncMap           template.FuncMap
	PackageName       string
	Imports           *intimports.Imports
	EditableCode      bool
}

func (fw *TemplatedBasedFileWriter) createDirIfNeeded() bool {
	return fw.CreateDirIfNeeded
}

func (fw *TemplatedBasedFileWriter) getPathToFile() string {
	return fw.PathToFile
}

func (fw *TemplatedBasedFileWriter) generateBytes() ([]byte, error) {
	// execute template
	buf, err := fw.executeTemplate()
	if err != nil {
		return nil, err
	}

	// better flag needed. but basically not go code and we can bounce
	if !fw.FormatSource {
		return buf.Bytes(), nil
	}

	// formatting typescript
	// vs formatting go!
	if strings.HasSuffix(fw.getPathToFile(), ".go") {
		return fw.formatGo(buf)
	} else if strings.HasSuffix(fw.getPathToFile(), ".ts") {
		return fw.formatTs(buf)
	}
	return nil, fmt.Errorf("cannot format source for non-go or ts file")
}

func (fw *TemplatedBasedFileWriter) formatGo(buf *bytes.Buffer) ([]byte, error) {
	var b []byte
	var err error
	if fw.Imports != nil {
		buf, err = fw.handleManualImports(buf)
		if err != nil {
			return nil, err
		}
	}

	b, err = imports.Process(
		fw.PathToFile,
		buf.Bytes(),
		&imports.Options{
			FormatOnly: false,
			Comments:   true,
			TabIndent:  true,
			TabWidth:   8,
		},
	)
	if err != nil {
		fmt.Println(string(buf.Bytes()))
	}

	return b, err
}

func (fw *TemplatedBasedFileWriter) formatTs(buf *bytes.Buffer) ([]byte, error) {
	// options: https://prettier.io/docs/en/options.html
	args := []string{
		"--trailing-comma", "es5",
		"--quote-props", "consistent",
		"--parser", "typescript",
		"--end-of-line", "lf",
	}
	// also needs to be part of the docker container
	cmd := exec.Command("prettier", args...)
	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr
	cmd.Stdin = buf

	if err := cmd.Run(); err != nil {
		str := stderr.String()
		err = errors.Wrap(err, str)
		return nil, err
	}
	return out.Bytes(), nil
}

func (fw *TemplatedBasedFileWriter) executeTemplate() (*bytes.Buffer, error) {
	path := []string{fw.AbsPathToTemplate}
	t := template.New(fw.TemplateName).Funcs(fw.FuncMap)
	t, err := t.ParseFiles(path...)
	if err != nil {
		return nil, err
	}

	var buffer bytes.Buffer

	// execute the template and store in buffer
	err = t.Execute(&buffer, fw.Data)
	return &buffer, err
}

func (fw *TemplatedBasedFileWriter) handleManualImports(buf *bytes.Buffer) (*bytes.Buffer, error) {
	var result bytes.Buffer
	if fw.EditableCode {
		result.WriteString("// Code generated by github.com/lolopinto/ent/ent. \n\n")
	} else {
		result.WriteString("// Code generated by github.com/lolopinto/ent/ent, DO NOT EDIT.\n\n")
	}

	result.WriteString("package ")
	result.WriteString(fw.PackageName)
	result.WriteString("\n\n")
	result.WriteString("import (\n")
	result.WriteString(fw.Imports.String())
	result.WriteString(")\n")
	_, err := buf.WriteTo(&result)

	return &result, err
}

func (fw *TemplatedBasedFileWriter) Write(opts ...func(opt *Options)) error {
	return writeFile(fw, opts...)
}
