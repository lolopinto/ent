{{with .NodeData -}}
{{/* TODO break this up to make it easier to use? */}}
{{/* these are dependent on having the right tsconfig.json file... */}}
{{ reserveImport "ent/ent" "loadEnt" "ID" "Viewer" "loadEntX" "loadEnts" "LoadEntOptions" "createEnt" "editEnt" "deleteEnt" "AssocEdge" "loadEdges" "loadRawEdgeCountX" "loadNodesByEdge" "loadEdgeForID2" "loadEntsFromClause" "loadEntFromClause" "loadEntXFromClause" "loadRow" "loadUniqueEdge" "loadUniqueNode" }}
{{ reserveImport "ent/privacy" "AlwaysDenyRule" "PrivacyPolicy"}}
{{ reserveImport "ent/schema" "Field" "getFields"}}
{{ $schemaPath := printf "src/schema/%s" .PackageName }}
{{ reserveDefaultImport $schemaPath "schema"}}
{{ reserveImport "src/ent/const" "EdgeType" }}
{{ reserveAllImport "ent/query" "query" }}

{{ range .GetUniqueNodes -}} 
  {{$packagePath := printf "src/ent/%s" .PackageName }}
  {{ reserveDefaultImport $packagePath .Node}}
{{ end}}

{{$viewerType := useImport "Viewer"}}
{{$idType := useImport "ID" }}

const tableName = "{{.TableName}}";

{{$baseClass := printf "%sBase" .Node -}}
{{$constructor := "arg: new (viewer: Viewer, id: ID, data: {}) => T"}}
{{$thisType := "new (viewer: Viewer, id: ID, data: {}) => T"}}

export class {{$baseClass}} {

  {{range $field := .FieldInfo.Fields -}}
    readonly {{$field.TsFieldName}}: {{$field.TsType}};
  {{end}}

  constructor(public viewer: {{$viewerType}}, id: {{$idType}}, data:{}) {
    this.id = id;
    // TODO don't double read id
    {{range $field := .FieldInfo.Fields -}}
      this.{{$field.TsFieldName}} = data['{{$field.GetDbColName}}'];
    {{end}}
  }

  // by default, we always deny and it's up to the ent 
  // to overwrite this privacy policy in its subclasses
  {{/* TODO: make this configurable */}} 
  privacyPolicy: {{useImport "PrivacyPolicy"}} = {
    rules: [{{useImport "AlwaysDenyRule"}}],
  };

  static async load<T extends {{$baseClass}}>(
    this: {{$thisType}},
    viewer: {{$viewerType}}, 
    id: {{$idType}},
  ): Promise<T | null>{
    return {{useImport "loadEnt"}}(
      viewer, 
      id, 
      {{$baseClass}}.loaderOptions.apply(this),
    );
  }

  static async loadX<T extends {{$baseClass}}>(
    this: {{$thisType}},
    viewer: {{$viewerType}}, 
    id: {{$idType}},
  ): Promise<T> {
    return {{useImport "loadEntX"}}(
      viewer, 
      id, 
      {{$baseClass}}.loaderOptions.apply(this),
    );
  }

  static async loadMany<T extends {{$baseClass}}>(
    this: {{$thisType}},
    viewer: {{$viewerType}},
    ...ids: {{$idType}}[],
  ): Promise<T[]> {
    return {{useImport "loadEnts"}}(
      viewer, 
      {{$baseClass}}.loaderOptions.apply(this), 
      ...ids,
    );
  }

  {{ range $field := .FieldInfo.Fields -}}
    {{ if or $field.Index $field.Unique -}}
      static async loadFrom{{$field.CamelCaseName}}<T extends {{$baseClass}}>(
        this: {{$thisType}},
        viewer: {{$viewerType}},
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<T | null> {
        return {{useImport "loadEntFromClause"}}(
          viewer, 
          {{$baseClass}}.loaderOptions.apply(this), 
          query.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        );
      }

      static async loadFrom{{$field.CamelCaseName}}X<T extends {{$baseClass}}>(
        this: {{$thisType}},
        viewer: Viewer,
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<T> {
        return {{useImport "loadEntXFromClause"}}(
          viewer, 
          {{$baseClass}}.loaderOptions.apply(this), 
          query.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        );
      }

      static async loadIDFrom{{$field.CamelCaseName}}<T extends {{$baseClass}}>(
        this: {{$thisType}},
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<{{$idType}} | null> {
        const row = await {{useImport "loadRow"}}({
          ...{{$baseClass}}.loaderOptions.apply(this),
          clause: query.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        }); 
        if (!row) { return null;}
        return row['id'];
      }

    {{end -}}
  {{end -}}

  static loaderOptions<T extends {{$baseClass}}>(
    this: new (viewer: {{$viewerType}}, id: {{$idType}}, data: {}) => T,
  ): {{useImport "LoadEntOptions"}}<T> {
    return {
      tableName: tableName,
      fields: {{$baseClass}}.getFields(),
      ent: this,
    };
  }

  private static getFields(): string[] {
    return [
    {{range $field := .FieldInfo.Fields -}}
      '{{$field.GetDbColName}}',
    {{end}}
    ];
  }

  private static schemaFields: Map<string, {{useImport "Field"}}>;

  private static getSchemaFields(): Map<string, {{useImport "Field"}}> {
    if ({{$baseClass}}.schemaFields != null) {
      return {{$baseClass}}.schemaFields;
    }
    return {{$baseClass}}.schemaFields = {{useImport "getFields"}}({{useImport "schema"}});
  }

  static getField(key: string): {{useImport "Field"}} | undefined{
    return {{$baseClass}}.getSchemaFields().get(key);
  }

  {{/* load edges and load objects */ -}}
  {{range $edge := .EdgeInfo.Associations -}}
    {{$edgeName := .CamelCaseEdgeName -}}
    {{$uniqueEdge := .Unique -}}
    {{with .NodeInfo -}}
    {{$edgeType := useImport "EdgeType"}}
    {{$assocEdgeType := useImport "AssocEdge"}}
     {{/* TODO unique edges */}}
     {{ if $uniqueEdge -}}
      load{{$edgeName}}Edge(): Promise<{{$assocEdgeType}} | null> {
        return {{useImport "loadUniqueEdge"}}(
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}},
        );
      }

      load{{$edgeName}}(): Promise<{{.Node}} | null> {
        return {{useImport "loadUniqueNode"}}(
          this.viewer, 
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}}, 
          {{.Node}}.loaderOptions(),
        );
      }

     {{ else -}}
      load{{$edgeName}}Edges():Promise<{{$assocEdgeType}}[]> {
        return {{useImport "loadEdges"}}(
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}},
        );
      }

      load{{$edgeName}}():Promise<{{useImport .Node}}[]> {
        return {{useImport "loadNodesByEdge"}}(
          this.viewer, 
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}}, 
          {{useImport .Node}}.loaderOptions(),
        );
      }

      load{{$edgeName}}RawCountX():Promise<number> {
        return {{useImport "loadRawEdgeCountX"}}(
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}},
        );
      }

      load{{$edge.Singular}}EdgeFor(id2: {{$idType}}):Promise<{{$assocEdgeType}}|undefined> {
        return {{useImport "loadEdgeForID2"}}(
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}}, 
          id2,
        );
      }
     {{end}}
    {{end -}}
  {{end -}}

  {{ range $edge := .EdgeInfo.ForeignKeys -}}
    {{$edgeName := .CamelCaseEdgeName -}}
    {{with .NodeInfo -}}
      load{{$edgeName}}(): Promise<{{useImport .Node}}[]> {
        return {{useImport "loadEntsFromClause"}}(
          this.viewer, 
          {{useImport "query"}}.Eq({{$edge.QuotedDBColName}}, this.id), 
          {{useImport .Node}}.loaderOptions(),
        );
      }

    {{end -}}
  {{end -}}

  {{ range $edge := .EdgeInfo.FieldEdges -}}
    {{$edgeName := .CamelCaseEdgeName -}}
    {{with .NodeInfo -}}
      load{{$edgeName}}(): Promise<{{useImport .Node}}|null> {
        return {{useImport "loadEnt"}}(
          this.viewer, 
          this.{{$edge.FieldName}},
          {{useImport .Node}}.loaderOptions(),
        );
      }

      load{{$edgeName}}X(): Promise<{{useImport .Node}}> {
        return {{useImport "loadEntX"}}(
          this.viewer, 
          this.{{$edge.FieldName}},
          {{useImport .Node}}.loaderOptions(),
        );
      }
    {{end -}}
  {{end -}}
}

// no actions yet so we support full create, edit, delete for now
export interface {{.Node}}CreateInput {
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      {{/* if nullable or has default value, make it optional */ -}}
      {{if or $field.Nullable $field.HasDefaultValueOnCreate -}}
        {{$field.TsFieldName}}?: {{$field.TsType}};
      {{else -}}
        {{$field.TsFieldName}}: {{$field.TsType}};
      {{end -}}
    {{ end -}}
  {{end}}
}

export interface {{.Node}}EditInput {
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      {{$field.TsFieldName}}?: {{$field.TsType}};
    {{ end -}}
  {{end}}
}

function defaultValue (key: string, property: string): any {
  let fn = {{$baseClass}}.getField(key)?.[property];
  if (!fn) {
    return null;
  }
  return fn();
};

export async function create{{.Node}}From<T extends {{$baseClass}}>(
  viewer: {{$viewerType}}, 
  input: {{.Node}}CreateInput,
  {{$constructor}},
  ): Promise<T | null> {
  let fields  = {
    {{range $field := .FieldInfo.Fields -}}
      {{ if $field.EditableField -}}
        "{{$field.GetDbColName}}": input.{{$field.TsFieldName}},
      {{ else if $field.HasDefaultValueOnCreate -}}
        "{{$field.GetDbColName}}": defaultValue("{{$field.FieldName}}", "defaultValueOnCreate"),
      {{end -}}
    {{end -}}
  };

  return await {{useImport "createEnt"}}(
    viewer, 
    {
      tableName: tableName,
      fields: fields,
      ent: arg,
    }
  );
}

export async function edit{{.Node}}From<T extends {{$baseClass}}>(
  viewer: {{$viewerType}}, 
  id: {{$idType}}, 
  input: {{.Node}}EditInput,
  {{$constructor}},
): Promise<T | null> {
  const setField = function(key: string, value: any) {
    if (value !== undefined) { // nullable fields allowed
      fields[key] = value;
    }
  };
  let fields  = {
    {{range $field := .FieldInfo.Fields -}}
      {{ if $field.HasDefaultValueOnEdit -}}
        "{{$field.GetDbColName}}": defaultValue("{{$field.FieldName}}", "defaultValueOnEdit"),
      {{end -}}
    {{end -}}
  };
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      setField("{{$field.GetDbColName}}", input.{{$field.TsFieldName}});
    {{end -}}
  {{end}}

  return await {{useImport "editEnt"}}(
    viewer,
    id,
    {
      tableName: tableName,
      fields: fields,
      ent: arg,
    }
  );
}

export async function delete{{.Node}}(viewer: Viewer, id: ID): Promise<null> {
  return await {{useImport "deleteEnt"}}(
    viewer,
    id,
    {
      tableName: tableName,
    }
  );
};
{{end -}}