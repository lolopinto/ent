// these are dependent on having the right tsconfig.json file...
{{with .NodeData -}}
import {loadEnt, ID, Viewer, loadEntX, LoadEntOptions, createEnt, editEnt, deleteEnt} from "ent/ent";
import {AlwaysDenyRule, PrivacyPolicy} from "ent/privacy";
import {Field, getFields} from "ent/schema";
import schema from "src/schema/{{.PackageName}}";

const tableName = "{{.TableName}}";

{{$baseClass := printf "%sBase" .Node -}}
{{$constructor := "arg: new (viewer: Viewer, id: ID, data: {}) => T"}}

export abstract class {{$baseClass}} {

  {{range $field := .FieldInfo.Fields -}}
    readonly {{$field.TsFieldName}}: {{$field.TsType}};
  {{end}}

  constructor(public viewer: Viewer, id: ID, data:{}) {
    this.id = id;
    // TODO don't double read id
    {{range $field := .FieldInfo.Fields -}}
      this.{{$field.TsFieldName}} = data['{{$field.GetDbColName}}'];
    {{end}}
  }

  // by default, we always deny and it's up to the ent 
  // to overwrite this privacy policy in its subclasses
  {{/* TODO: make this configurable */}} 
  privacyPolicy: PrivacyPolicy = {
    rules: [AlwaysDenyRule],
  };

  protected static async loadFrom<T extends {{$baseClass}}>(
    viewer: Viewer, 
    id: ID,
    {{$constructor}},
  ): Promise<T | null>{
    return loadEnt(viewer, id, {{$baseClass}}.getOptions(arg));
  }

  protected static async loadXFrom<T extends {{$baseClass}}>(
    viewer: Viewer, 
    id: ID,
    {{$constructor}},
  ): Promise<T> {
    return loadEntX(viewer, id, {{$baseClass}}.getOptions(arg));
  }

  private static getFields(): string[] {
    return [
    {{range $field := .FieldInfo.Fields -}}
      '{{$field.GetDbColName}}',
    {{end}}
    ];
  }

  private static schemaFields: Map<string,Field>;

  private static getSchemaFields(): Map<string, Field> {
    if ({{$baseClass}}.schemaFields != null) {
      return {{$baseClass}}.schemaFields;
    }
    return {{$baseClass}}.schemaFields = getFields(schema);
  }

  static getField(key: string): Field | undefined{
    return {{$baseClass}}.getSchemaFields().get(key);
  }

  private static getOptions<T extends {{$baseClass}}>(
    {{$constructor}},
  ): LoadEntOptions<T> {
    return {
      tableName: tableName,
      fields: {{$baseClass}}.getFields(),
      ent: arg,
    };
  }
}

// no actions yet so we support full create, edit, delete for now
export interface {{.Node}}CreateInput {
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      {{/* if nullable or has default value, make it optional */ -}}
      {{if or $field.Nullable $field.HasDefaultValueOnCreate -}}
        {{$field.TsFieldName}}?: {{$field.TsType}};
      {{else -}}
        {{$field.TsFieldName}}: {{$field.TsType}};
      {{end -}}
    {{ end -}}
  {{end}}
}

export interface {{.Node}}EditInput {
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      {{$field.TsFieldName}}?: {{$field.TsType}};
    {{ end -}}
  {{end}}
}

function defaultValue (key: string, property: string): any {
  let fn = {{$baseClass}}.getField(key)?.[property];
  if (!fn) {
    return null;
  }
  return fn();
};

export async function create{{.Node}}From<T extends {{$baseClass}}>(
  viewer: Viewer, 
  input: {{.Node}}CreateInput,
  {{$constructor}},
  ): Promise<T | null> {
  let fields  = {
    {{range $field := .FieldInfo.Fields -}}
      {{ if $field.EditableField -}}
        "{{$field.GetDbColName}}": input.{{$field.TsFieldName}},
      {{ else if $field.HasDefaultValueOnCreate -}}
        "{{$field.GetDbColName}}": defaultValue("{{$field.FieldName}}", "defaultValueOnCreate"),
      {{end -}}
    {{end -}}
  };

  return await createEnt(
    viewer, 
    {
      tableName: tableName,
      fields: fields,
      ent: arg,
    }
  );
}

export async function edit{{.Node}}From<T extends {{$baseClass}}>(
  viewer: Viewer, 
  id: ID, 
  input: {{.Node}}EditInput,
  {{$constructor}},
): Promise<T | null> {
  const setField = function(key: string, value: any) {
    if (value !== undefined) { // nullable fields allowed
      fields[key] = value;
    }
  };
  let fields  = {
    {{range $field := .FieldInfo.Fields -}}
      {{ if $field.HasDefaultValueOnEdit -}}
        "{{$field.GetDbColName}}": defaultValue("{{$field.FieldName}}", "defaultValueOnEdit"),
      {{end -}}
    {{end -}}
  };
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      setField("{{$field.GetDbColName}}", input.{{$field.TsFieldName}});
    {{end -}}
  {{end}}

  return await editEnt(
    viewer,
    id,
    {
      tableName: tableName,
      fields: fields,
      ent: arg,
    }
  );
}

export async function delete{{.Node}}(viewer: Viewer, id: ID): Promise<null> {
  return await deleteEnt(
    viewer,
    id,
    {
      tableName: tableName,
    }
  );
};
{{end -}}