{{with .NodeData -}}
{{/* TODO break this up to make it easier to use? */}}
{{/* these are dependent on having the right tsconfig.json file... */}}
{{ reserveImport "ent/ent" "loadEnt" "ID" "Viewer" "loadEntX" "loadEnts" "LoadEntOptions" "AssocEdge" "loadEdges" "loadRawEdgeCountX" "loadNodesByEdge" "loadEdgeForID2" "loadEntsFromClause" "loadEntFromClause" "loadEntXFromClause" "loadRow" "loadUniqueEdge" "loadUniqueNode" }}
{{ reserveImport "ent/privacy" "AlwaysDenyRule" "PrivacyPolicy"}}
{{ reserveImport "ent/schema" "Field" "getFields"}}
{{ $schemaPath := printf "src/schema/%s" .PackageName }}
{{ reserveDefaultImport $schemaPath "schema"}}
{{ reserveImport "src/ent/const" "EdgeType" "NodeType" }}
{{ reserveAllImport "ent/query" "query" }}

{{ range .GetUniqueNodes -}} 
  {{$packagePath := printf "src/ent/%s" .PackageName }}
  {{ reserveDefaultImport $packagePath .Node}}
{{ end}}

{{$viewerType := useImport "Viewer"}}
{{$idType := useImport "ID" }}

const tableName = "{{.TableName}}";

{{$baseClass := printf "%sBase" .Node -}}
{{$constructor := "arg: new (viewer: Viewer, id: ID, data: {}) => T"}}
{{$thisType := "new (viewer: Viewer, id: ID, data: {}) => T"}}

export class {{$baseClass}} {

  readonly nodeType = {{useImport "NodeType"}}.{{.Node}};
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.Private -}}
      protected readonly {{$field.TsFieldName}}: {{$field.TsType}};
    {{ else -}}
      readonly {{$field.TsFieldName}}: {{$field.TsType}};
    {{end -}}
  {{end}}

  constructor(public viewer: {{$viewerType}}, id: {{$idType}}, data:{}) {
    this.id = id;
    // TODO don't double read id
    {{range $field := .FieldInfo.Fields -}}
      this.{{$field.TsFieldName}} = data['{{$field.GetDbColName}}'];
    {{end}}
  }

  // by default, we always deny and it's up to the ent 
  // to overwrite this privacy policy in its subclasses
  {{/* TODO: make this configurable */}} 
  privacyPolicy: {{useImport "PrivacyPolicy"}} = {
    rules: [{{useImport "AlwaysDenyRule"}}],
  };

  static async load<T extends {{$baseClass}}>(
    this: {{$thisType}},
    viewer: {{$viewerType}}, 
    id: {{$idType}},
  ): Promise<T | null>{
    return {{useImport "loadEnt"}}(
      viewer, 
      id, 
      {{$baseClass}}.loaderOptions.apply(this),
    );
  }

  static async loadX<T extends {{$baseClass}}>(
    this: {{$thisType}},
    viewer: {{$viewerType}}, 
    id: {{$idType}},
  ): Promise<T> {
    return {{useImport "loadEntX"}}(
      viewer, 
      id, 
      {{$baseClass}}.loaderOptions.apply(this),
    );
  }

  static async loadMany<T extends {{$baseClass}}>(
    this: {{$thisType}},
    viewer: {{$viewerType}},
    ...ids: {{$idType}}[],
  ): Promise<T[]> {
    return {{useImport "loadEnts"}}(
      viewer, 
      {{$baseClass}}.loaderOptions.apply(this), 
      ...ids,
    );
  }

  {{ range $field := .FieldInfo.Fields -}}
    {{ if or $field.Index $field.Unique -}}
      static async loadFrom{{$field.CamelCaseName}}<T extends {{$baseClass}}>(
        this: {{$thisType}},
        viewer: {{$viewerType}},
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<T | null> {
        return {{useImport "loadEntFromClause"}}(
          viewer, 
          {{$baseClass}}.loaderOptions.apply(this), 
          query.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        );
      }

      static async loadFrom{{$field.CamelCaseName}}X<T extends {{$baseClass}}>(
        this: {{$thisType}},
        viewer: Viewer,
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<T> {
        return {{useImport "loadEntXFromClause"}}(
          viewer, 
          {{$baseClass}}.loaderOptions.apply(this), 
          query.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        );
      }

      static async loadIDFrom{{$field.CamelCaseName}}<T extends {{$baseClass}}>(
        this: {{$thisType}},
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<{{$idType}} | null> {
        const row = await {{useImport "loadRow"}}({
          ...{{$baseClass}}.loaderOptions.apply(this),
          clause: query.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        }); 
        if (!row) { return null;}
        return row['id'];
      }

    {{end -}}
  {{end -}}

  static loaderOptions<T extends {{$baseClass}}>(
    this: new (viewer: {{$viewerType}}, id: {{$idType}}, data: {}) => T,
  ): {{useImport "LoadEntOptions"}}<T> {
    return {
      tableName: tableName,
      fields: {{$baseClass}}.getFields(),
      ent: this,
    };
  }

  private static getFields(): string[] {
    return [
    {{range $field := .FieldInfo.Fields -}}
      '{{$field.GetDbColName}}',
    {{end}}
    ];
  }

  private static schemaFields: Map<string, {{useImport "Field"}}>;

  private static getSchemaFields(): Map<string, {{useImport "Field"}}> {
    if ({{$baseClass}}.schemaFields != null) {
      return {{$baseClass}}.schemaFields;
    }
    return {{$baseClass}}.schemaFields = {{useImport "getFields"}}({{useImport "schema"}});
  }

  static getField(key: string): {{useImport "Field"}} | undefined{
    return {{$baseClass}}.getSchemaFields().get(key);
  }

  {{/* load edges and load objects */ -}}
  {{range $edge := .EdgeInfo.Associations -}}
    {{$edgeName := .CamelCaseEdgeName -}}
    {{$uniqueEdge := .Unique -}}
    {{with .NodeInfo -}}
    {{$edgeType := useImport "EdgeType"}}
    {{$assocEdgeType := useImport "AssocEdge"}}
     {{/* TODO unique edges */}}
     {{ if $uniqueEdge -}}
      load{{$edgeName}}Edge(): Promise<{{$assocEdgeType}} | null> {
        return {{useImport "loadUniqueEdge"}}(
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}},
        );
      }

      load{{$edgeName}}(): Promise<{{.Node}} | null> {
        return {{useImport "loadUniqueNode"}}(
          this.viewer, 
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}}, 
          {{.Node}}.loaderOptions(),
        );
      }

     {{ else -}}
      load{{$edgeName}}Edges():Promise<{{$assocEdgeType}}[]> {
        return {{useImport "loadEdges"}}(
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}},
        );
      }

      load{{$edgeName}}():Promise<{{useImport .Node}}[]> {
        return {{useImport "loadNodesByEdge"}}(
          this.viewer, 
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}}, 
          {{useImport .Node}}.loaderOptions(),
        );
      }

      load{{$edgeName}}RawCountX():Promise<number> {
        return {{useImport "loadRawEdgeCountX"}}(
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}},
        );
      }

      load{{$edge.Singular}}EdgeFor(id2: {{$idType}}):Promise<{{$assocEdgeType}}|undefined> {
        return {{useImport "loadEdgeForID2"}}(
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}}, 
          id2,
        );
      }
     {{end}}
    {{end -}}
  {{end -}}

  {{ range $edge := .EdgeInfo.ForeignKeys -}}
    {{$edgeName := .CamelCaseEdgeName -}}
    {{with .NodeInfo -}}
      async load{{$edgeName}}(): Promise<{{useImport .Node}}[]> {
        let map = await {{useImport "loadEntsFromClause"}}(
          this.viewer, 
          {{useImport "query"}}.Eq({{$edge.QuotedDBColName}}, this.id), 
          {{useImport .Node}}.loaderOptions(),
        );
        let results: {{useImport .Node}}[] = [];
        map.forEach((ent) => {
          results.push(ent);
        })
        return results;
      }

    {{end -}}
  {{end -}}

  {{ range $edge := .EdgeInfo.FieldEdges -}}
    {{$edgeName := .CamelCaseEdgeName -}}
    {{with .NodeInfo -}}
      load{{$edgeName}}(): Promise<{{useImport .Node}}|null> {
        return {{useImport "loadEnt"}}(
          this.viewer, 
          this.{{$edge.FieldName}},
          {{useImport .Node}}.loaderOptions(),
        );
      }

      load{{$edgeName}}X(): Promise<{{useImport .Node}}> {
        return {{useImport "loadEntX"}}(
          this.viewer, 
          this.{{$edge.FieldName}},
          {{useImport .Node}}.loaderOptions(),
        );
      }
    {{end -}}
  {{end -}}
}

{{end -}}