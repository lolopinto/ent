{{ reserveImport .Package.PackagePath "loadEnt" "ID" "Data" "Viewer" "loadEntX" "loadEnts" "LoadEntOptions" "AssocEdge" "loadEdges" "loadRawEdgeCountX" "loadNodesByEdge" "loadEdgeForID2" "loadEntsFromClause" "loadEntFromClause" "loadEntXFromClause" "loadRow" "loadRows" "loadRowX" "loadUniqueEdge" "loadUniqueNode" "AlwaysDenyRule" "AllowIfViewerRule" "PrivacyPolicy" "query" "Ent" "getEdgeTypeInGroup"}}
{{ reserveImport .Package.SchemaPackagePath "Field" "getFields"}}
{{ reserveImport .Package.InternalImportPath "EdgeType" "NodeType" }}
{{ reserveImport "src/ent/loadAny" "loadEntByType" "loadEntXByType"}}

{{with .NodeData -}}
{{/* TODO break this up to make it easier to use? */}}
{{/* these are dependent on having the right tsconfig.json file... */}}
{{ $schemaPath := printf "src/schema/%s" .PackageName }}
{{ reserveDefaultImport $schemaPath "schema"}}

{{ range .GetImportsForBaseFile -}} 
  {{ if .DefaultImport -}}
    {{ reserveDefaultImport .PackagePath .Import}}
  {{ else -}}
    {{ reserveImport .PackagePath .Import}}
  {{end -}}
{{ end}}

{{$viewerType := useImport "Viewer"}}
{{$idType := useImport "ID" }}
{{$dataType := useImport "Data" }}

const tableName = "{{.TableName}}";

{{$baseClass := printf "%sBase" .Node -}}
{{$constructor := "arg: new (viewer: Viewer, id: ID, data: Data) => T"}}
{{$thisType := "new (viewer: Viewer, id: ID, data: Data) => T"}}

{{ range .GetTSEnums -}}
  {{if not .Imported -}}
    {{ template "enum.tmpl" . -}}
  {{end -}}
{{ end}}

export class {{$baseClass}} {

  readonly nodeType = {{useImport "NodeType"}}.{{.Node}};
  {{range $field := .FieldInfo.Fields -}}
    {{ if $typ := $field.ForeignImport -}}
      {{$typ = useImport $typ -}}
    {{end -}}
    {{ if $field.Private -}}
      protected readonly {{$field.TsFieldName}}: {{$field.TsType}};
    {{ else -}}
      readonly {{$field.TsFieldName}}: {{$field.TsType}};
    {{end -}}
  {{end}}

  constructor(public viewer: {{$viewerType}}, id: {{$idType}}, data:{{$dataType}}) {
    this.id = id;
    // TODO don't double read id
    {{range $field := .FieldInfo.Fields -}}
      this.{{$field.TsFieldName}} = data.{{$field.GetDbColName}};
    {{end}}
  }

  // by default, we always deny and it's up to the ent 
  // to overwrite this privacy policy in its subclasses
  {{/* TODO: make this configurable */}} 
  privacyPolicy: {{useImport "PrivacyPolicy"}} = {
    rules: [{{useImport "AllowIfViewerRule"}}, {{useImport "AlwaysDenyRule"}}],
  };

  static async load<T extends {{$baseClass}}>(
    this: {{$thisType}},
    viewer: {{$viewerType}}, 
    id: {{$idType}},
  ): Promise<T | null>{
    return {{useImport "loadEnt"}}(
      viewer, 
      id, 
      {{$baseClass}}.loaderOptions.apply(this),
    );
  }

  static async loadX<T extends {{$baseClass}}>(
    this: {{$thisType}},
    viewer: {{$viewerType}}, 
    id: {{$idType}},
  ): Promise<T> {
    return {{useImport "loadEntX"}}(
      viewer, 
      id, 
      {{$baseClass}}.loaderOptions.apply(this),
    );
  }

  static async loadMany<T extends {{$baseClass}}>(
    this: {{$thisType}},
    viewer: {{$viewerType}},
    ...ids: {{$idType}}[],
  ): Promise<T[]> {
    return {{useImport "loadEnts"}}(
      viewer, 
      {{$baseClass}}.loaderOptions.apply(this), 
      ...ids,
    );
  }

  static async loadRawData<T extends {{$baseClass}}>(
    this: {{$thisType}},
    id: ID,
  ): Promise<{{$dataType}} | null> {
    return await {{useImport "loadRow"}}({
      ...{{$baseClass}}.loaderOptions.apply(this),
      clause: {{useImport "query"}}.Eq("id", id),
    });
  }

  static async loadRawDataX<T extends {{$baseClass}}>(
    this: {{$thisType}},
    id: ID,
  ): Promise<{{$dataType}}> {
    return await {{useImport "loadRowX"}}({
      ...{{$baseClass}}.loaderOptions.apply(this),
      clause: {{useImport "query"}}.Eq("id", id),
    });
  }

  {{ range $field := .FieldInfo.Fields -}}
    {{ if $field.Unique -}}
      static async loadFrom{{$field.CamelCaseName}}<T extends {{$baseClass}}>(
        this: {{$thisType}},
        viewer: {{$viewerType}},
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<T | null> {
        return {{useImport "loadEntFromClause"}}(
          viewer, 
          {{$baseClass}}.loaderOptions.apply(this), 
          {{useImport "query"}}.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        );
      }

      static async loadFrom{{$field.CamelCaseName}}X<T extends {{$baseClass}}>(
        this: {{$thisType}},
        viewer: Viewer,
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<T> {
        return {{useImport "loadEntXFromClause"}}(
          viewer, 
          {{$baseClass}}.loaderOptions.apply(this), 
          {{useImport "query"}}.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        );
      }

      static async loadIDFrom{{$field.CamelCaseName}}<T extends {{$baseClass}}>(
        this: {{$thisType}},
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<{{$idType}} | null> {
        const row = await {{useImport "loadRow"}}({
          ...{{$baseClass}}.loaderOptions.apply(this),
          clause: {{useImport "query"}}.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        }); 
        if (!row) { return null;}
        return row['id'];
      }

      static async loadRawDataFrom{{$field.CamelCaseName}}<T extends {{$baseClass}}>(
        this: {{$thisType}},
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<{{$dataType}} | null> {
        return await {{useImport "loadRow"}}({
          ...{{$baseClass}}.loaderOptions.apply(this),
          clause: {{useImport "query"}}.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        }); 
      }
    {{ else if $field.Index -}}
      static async loadFrom{{$field.CamelCaseName}}<T extends {{$baseClass}}>(
        this: {{$thisType}},
        viewer: {{$viewerType}},
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<T[]> {
        const m = await {{useImport "loadEntsFromClause"}}(
          viewer, 
          {{useImport "query"}}.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
          {{$baseClass}}.loaderOptions.apply(this), 
        );
        return Array.from(m.values()) as T[];
      }

      static async loadIDsFrom{{$field.CamelCaseName}}<T extends {{$baseClass}}>(
        this: {{$thisType}},
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<{{$idType}}[] | null> {
        const rows = await {{useImport "loadRows"}}({
          ...{{$baseClass}}.loaderOptions.apply(this),
          clause: {{useImport "query"}}.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        }); 
        if (!rows) { return null;}
        return rows.map(row=> row['id']);
      }

      static async loadRawDataFrom{{$field.CamelCaseName}}<T extends {{$baseClass}}>(
        this: {{$thisType}},
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<{{$dataType}}[] | null> {
        return await {{useImport "loadRows"}}({
          ...{{$baseClass}}.loaderOptions.apply(this),
          clause: {{useImport "query"}}.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        }); 
      }
    {{end}}
  {{end -}}

  static loaderOptions<T extends {{$baseClass}}>(
    this: new (viewer: {{$viewerType}}, id: {{$idType}}, data: Data) => T,
  ): {{useImport "LoadEntOptions"}}<T> {
    return {
      tableName: tableName,
      fields: {{$baseClass}}.getFields(),
      ent: this,
    };
  }

  private static getFields(): string[] {
    return [
    {{range $field := .FieldInfo.Fields -}}
      '{{$field.GetDbColName}}',
    {{end}}
    ];
  }

  private static schemaFields: Map<string, {{useImport "Field"}}>;

  private static getSchemaFields(): Map<string, {{useImport "Field"}}> {
    if ({{$baseClass}}.schemaFields != null) {
      return {{$baseClass}}.schemaFields;
    }
    return {{$baseClass}}.schemaFields = {{useImport "getFields"}}({{useImport "schema"}});
  }

  static getField(key: string): {{useImport "Field"}} | undefined{
    return {{$baseClass}}.getSchemaFields().get(key);
  }

  {{ range $group := .EdgeInfo.AssocGroups -}}
    {{if $group.NullStateFn -}}
    // this should be overwritten by subclasses as needed. 
    protected async {{$group.NullStateFn}}() {
      return {{$group.ConstType}}.{{$group.DefaultNullState}};
    }
    {{end}}

    {{$group.GetStatusMapMethod}}() {
      let m:Map<{{$group.ConstType}}, {{useImport "EdgeType"}}> = new Map();
      {{range $k, $v := $group.GetStatusMap -}}
        m.set({{$group.ConstType}}.{{$k}}, {{useImport "EdgeType"}}.{{$v}});
      {{end -}}
      return m;
    }

    async {{$group.GetStatusMethod}}(): Promise<{{$group.ConstType}}> {
      {{if $group.NullStateFn -}}
        const ret = await this.{{$group.NullStateFn}}();
      {{else -}}
        const ret= {{$group.ConstType}}.{{$group.DefaultNullState}};
      {{end -}}
      if (!this.viewer.viewerID) {
        return ret;
      }
      const g = await {{useImport "getEdgeTypeInGroup"}}(
        this.viewer,
        this.id,
        this.viewer.viewerID!,
        this.get{{$group.ConstType}}Map(),
      );
      if (g) {
        return g[0];
      }
      return ret;
    }
  {{end -}}



  {{/* load edges and load objects */ -}}
  {{range $edge := .EdgeInfo.Associations -}}
    {{$edgeName := .CamelCaseEdgeName -}}
    {{$uniqueEdge := .Unique -}}
    {{with .NodeInfo -}}
    {{$edgeType := useImport "EdgeType"}}
    {{$assocEdgeType := useImport "AssocEdge"}}
     {{/* TODO unique edges */}}
     {{ if $uniqueEdge -}}
      load{{$edgeName}}Edge(): Promise<{{$assocEdgeType}} | null> {
        return {{useImport "loadUniqueEdge"}}({
          id1: this.id, 
          edgeType: {{$edgeType}}.{{$edge.TsEdgeConst}},
          context: this.viewer.context,
        });
      }

      load{{$edgeName}}(): Promise<{{.Node}} | null> {
        return {{useImport "loadUniqueNode"}}(
          this.viewer, 
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}}, 
          {{.Node}}.loaderOptions(),
        );
      }

     {{ else -}}
      load{{$edgeName}}Edges():Promise<{{$assocEdgeType}}[]> {
        return {{useImport "loadEdges"}}({
          id1:this.id, 
          edgeType: {{$edgeType}}.{{$edge.TsEdgeConst}},
          context: this.viewer.context,
        });
      }

      load{{$edgeName}}():Promise<{{useImport .Node}}[]> {
        return {{useImport "loadNodesByEdge"}}(
          this.viewer, 
          this.id, 
          {{$edgeType}}.{{$edge.TsEdgeConst}}, 
          {{useImport .Node}}.loaderOptions(),
        );
      }

      load{{$edgeName}}RawCountX():Promise<number> {
        return {{useImport "loadRawEdgeCountX"}}({
          id1: this.id, 
          edgeType: {{$edgeType}}.{{$edge.TsEdgeConst}},
          context: this.viewer.context,
        });
      }

      load{{$edge.Singular}}EdgeFor(id2: {{$idType}}):Promise<{{$assocEdgeType}}|undefined> {
        return {{useImport "loadEdgeForID2"}}({
          id1: this.id, 
          edgeType: {{$edgeType}}.{{$edge.TsEdgeConst}}, 
          id2,
          context: this.viewer.context,
          ctr: {{useImport "AssocEdge"}}
        });
      }
     {{end}}
    {{end -}}
  {{end -}}

  {{ range $edge := .EdgeInfo.ForeignKeys -}}
    {{$edgeName := .CamelCaseEdgeName -}}
    {{with .NodeInfo -}}
      async load{{$edgeName}}(): Promise<{{useImport .Node}}[]> {
        let map = await {{useImport "loadEntsFromClause"}}(
          this.viewer, 
          {{useImport "query"}}.Eq({{$edge.QuotedDBColName}}, this.id), 
          {{useImport .Node}}.loaderOptions(),
        );
        let results: {{useImport .Node}}[] = [];
        map.forEach((ent) => {
          results.push(ent);
        })
        return results;
      }

    {{end -}}
  {{end -}}

  {{ range $edge := .EdgeInfo.IndexedEdges -}}
    {{$edgeName := .CamelCaseEdgeName -}}
    {{$fNode := .NodeInfo.Node -}}

    {{ if .Unique -}}
      async load{{$edge.Singular}}(): Promise<{{useImport $fNode}} | null> {
        const nodes = await {{useImport $fNode}}.loadFrom{{$edge.TsFieldName}}(this.viewer, this.id);
        return nodes[0];
      }

    {{ else -}}
      load{{$edgeName}}(): Promise<{{useImport $fNode}}[]> {
        return {{useImport $fNode}}.loadFrom{{$edge.TSFieldName}}(this.viewer, this.id);
      }

    {{end -}}
  {{end -}}

  {{ range $edge := .EdgeInfo.FieldEdges -}}
    {{  $edgeName := .CamelCaseEdgeName -}}
    {{ if $edge.Polymorphic}}
      async load{{$edgeName}}(): Promise<{{useImport "Ent"}}| null>{
        {{ if $edge.Nullable -}}
          if (!this.{{$edge.TSFieldName}}) {
            return null;
          }
        {{end -}}
        return {{useImport "loadEntByType"}}(
          this.viewer,
          this.{{$edge.Polymorphic.NodeTypeField}} as unknown as {{useImport "NodeType"}},
          this.{{$edge.TSFieldName}},
        );
      }
      
      {{ if not $edge.Nullable -}}
        load{{$edgeName}}X(): Promise<{{useImport "Ent"}}> {
        return {{useImport "loadEntXByType"}}(
          this.viewer, 
          this.{{$edge.Polymorphic.NodeTypeField}} as unknown as {{useImport "NodeType"}},
          this.{{$edge.TSFieldName}},
        );
      }
      {{end -}}
    {{ else -}}
      {{with .NodeInfo -}}
        async load{{$edgeName}}(): Promise<{{useImport .Node}}|null> {
          {{ if $edge.Nullable -}}
            if (!this.{{$edge.TSFieldName}}) {
              return null;
            }
          {{end -}}
          return {{useImport "loadEnt"}}(
            this.viewer, 
            this.{{$edge.TSFieldName}},
            {{useImport .Node}}.loaderOptions(),
          );
        }

        {{if not $edge.Nullable -}}
          load{{$edgeName}}X(): Promise<{{useImport .Node}}> {
            return {{useImport "loadEntX"}}(
              this.viewer, 
              this.{{$edge.TSFieldName}},
              {{useImport .Node}}.loaderOptions(),
            );
          }
        {{end -}}
      {{end}}
    {{end}}
  {{end}}
}

{{end -}}