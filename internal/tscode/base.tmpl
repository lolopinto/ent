// these are dependent on having the right tsconfig.json file...
{{with .NodeData -}}
{{/* TODO handle imports that are not used. similar to reserveImport in goland */ -}}
import {
  loadEnt, 
  ID, 
  Viewer, 
  loadEntX, 
  loadEnts,
  LoadEntOptions, 
  createEnt, 
  editEnt, 
  deleteEnt, 
  AssocEdge,
  loadEdges,
  loadRawEdgeCountX,
  loadNodesByEdge,
  loadEdgeForID2,
  loadEntsFromClause,
  loadEntFromClause,
  loadEntXFromClause,
  loadRow,
  loadUniqueEdge,
  loadUniqueNode,
} from "ent/ent";
import {AlwaysDenyRule, PrivacyPolicy} from "ent/privacy";
import {Field, getFields} from "ent/schema";
import schema from "src/schema/{{.PackageName}}";
import { EdgeType } from "src/ent/const";
import * as query from "ent/query";
{{ range .GetUniqueNodes -}} 
  import {{.Node}} from "src/ent/{{.PackageName}}";
{{ end}}

const tableName = "{{.TableName}}";

{{$baseClass := printf "%sBase" .Node -}}
{{$constructor := "arg: new (viewer: Viewer, id: ID, data: {}) => T"}}
{{$thisType := "new (viewer: Viewer, id: ID, data: {}) => T"}}

export class {{$baseClass}} {

  {{range $field := .FieldInfo.Fields -}}
    readonly {{$field.TsFieldName}}: {{$field.TsType}};
  {{end}}

  constructor(public viewer: Viewer, id: ID, data:{}) {
    this.id = id;
    // TODO don't double read id
    {{range $field := .FieldInfo.Fields -}}
      this.{{$field.TsFieldName}} = data['{{$field.GetDbColName}}'];
    {{end}}
  }

  // by default, we always deny and it's up to the ent 
  // to overwrite this privacy policy in its subclasses
  {{/* TODO: make this configurable */}} 
  privacyPolicy: PrivacyPolicy = {
    rules: [AlwaysDenyRule],
  };

  static async load<T extends {{$baseClass}}>(
    this: {{$thisType}},
    viewer: Viewer, 
    id: ID,
  ): Promise<T | null>{
    return loadEnt(viewer, id, {{$baseClass}}.loaderOptions.apply(this));
  }

  static async loadX<T extends {{$baseClass}}>(
    this: {{$thisType}},
    viewer: Viewer, 
    id: ID,
  ): Promise<T> {
    return loadEntX(viewer, id, {{$baseClass}}.loaderOptions.apply(this));
  }

  static async loadMany<T extends {{$baseClass}}>(
    this: {{$thisType}},
    viewer: Viewer,
    ...ids: ID[],
  ): Promise<T[]> {
    return loadEnts(viewer, {{$baseClass}}.loaderOptions.apply(this), ...ids);
  }

  {{ range $field := .FieldInfo.Fields -}}
    {{ if or $field.Index $field.Unique -}}
      static async loadFrom{{$field.CamelCaseName}}<T extends {{$baseClass}}>(
        this: {{$thisType}},
        viewer: Viewer,
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<T | null> {
        return loadEntFromClause(
          viewer, 
          {{$baseClass}}.loaderOptions.apply(this), 
          query.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        );
      }

      static async loadFrom{{$field.CamelCaseName}}X<T extends {{$baseClass}}>(
        this: {{$thisType}},
        viewer: Viewer,
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<T> {
        return loadEntXFromClause(
          viewer, 
          {{$baseClass}}.loaderOptions.apply(this), 
          query.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        );
      }

      static async loadIDFrom{{$field.CamelCaseName}}<T extends {{$baseClass}}>(
        this: {{$thisType}},
        {{$field.TsFieldName}}: {{$field.GetNotNullableTsType}},
      ): Promise<ID | null> {
        const row = await loadRow({
          ...{{$baseClass}}.loaderOptions.apply(this),
          clause: query.Eq({{$field.GetQuotedDBColName}}, {{$field.TsFieldName}}),
        }); 
        if (!row) { return null;}
        return row['id'];
      }

    {{end -}}
  {{end -}}

  static loaderOptions<T extends {{$baseClass}}>(
    this: new (viewer: Viewer, id: ID, data: {}) => T,
  ): LoadEntOptions<T> {
    return {
      tableName: tableName,
      fields: {{$baseClass}}.getFields(),
      ent: this,
    };
  }

  private static getFields(): string[] {
    return [
    {{range $field := .FieldInfo.Fields -}}
      '{{$field.GetDbColName}}',
    {{end}}
    ];
  }

  private static schemaFields: Map<string,Field>;

  private static getSchemaFields(): Map<string, Field> {
    if ({{$baseClass}}.schemaFields != null) {
      return {{$baseClass}}.schemaFields;
    }
    return {{$baseClass}}.schemaFields = getFields(schema);
  }

  static getField(key: string): Field | undefined{
    return {{$baseClass}}.getSchemaFields().get(key);
  }

  {{/* load edges and load objects */ -}}
  {{range $edge := .EdgeInfo.Associations -}}
    {{$edgeName := .CamelCaseEdgeName -}}
    {{$uniqueEdge := .Unique -}}
    {{with .NodeInfo -}}
     {{/* TODO unique edges */}}
     {{ if $uniqueEdge -}}
      load{{$edgeName}}Edge(): Promise<AssocEdge | null> {
        return loadUniqueEdge(this.id, EdgeType.{{$edge.TsEdgeConst}});
      }

      load{{$edgeName}}(): Promise<{{.Node}} | null> {
        return loadUniqueNode(this.viewer, this.id, EdgeType.{{$edge.TsEdgeConst}}, {{.Node}}.loaderOptions());
      }

     {{ else -}}
      load{{$edgeName}}Edges():Promise<AssocEdge[]> {
        return loadEdges(this.id, EdgeType.{{$edge.TsEdgeConst}});
      }

      load{{$edgeName}}():Promise<{{.Node}}[]> {
        return loadNodesByEdge(this.viewer, this.id, EdgeType.{{$edge.TsEdgeConst}}, {{.Node}}.loaderOptions());
      }

      load{{$edgeName}}RawCountX():Promise<number> {
        return loadRawEdgeCountX(this.id, EdgeType.{{$edge.TsEdgeConst}});
      }

      load{{$edge.Singular}}EdgeFor(id2: ID):Promise<AssocEdge|undefined> {
        return loadEdgeForID2(this.id, EdgeType.{{$edge.TsEdgeConst}}, id2);
      }
     {{end}}
    {{end -}}
  {{end -}}

  {{ range $edge := .EdgeInfo.ForeignKeys -}}
    {{$edgeName := .CamelCaseEdgeName -}}
    {{with .NodeInfo -}}
      load{{$edgeName}}(): Promise<{{.Node}}[]> {
        return loadEntsFromClause(
          this.viewer, 
          query.Eq({{$edge.QuotedDBColName}}, this.id), 
          {{.Node}}.loaderOptions(),
        );
      }

    {{end -}}
  {{end -}}

  {{ range $edge := .EdgeInfo.FieldEdges -}}
    {{$edgeName := .CamelCaseEdgeName -}}
    {{with .NodeInfo -}}
      load{{$edgeName}}(): Promise<{{.Node}}|null> {
        return loadEnt(
          this.viewer, 
          this.{{$edge.FieldName}},
          {{.Node}}.loaderOptions(),
        );
      }

      load{{$edgeName}}X(): Promise<{{.Node}}> {
        return loadEntX(
          this.viewer, 
          this.{{$edge.FieldName}},
          {{.Node}}.loaderOptions(),
        );
      }
    {{end -}}
  {{end -}}
}

// no actions yet so we support full create, edit, delete for now
export interface {{.Node}}CreateInput {
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      {{/* if nullable or has default value, make it optional */ -}}
      {{if or $field.Nullable $field.HasDefaultValueOnCreate -}}
        {{$field.TsFieldName}}?: {{$field.TsType}};
      {{else -}}
        {{$field.TsFieldName}}: {{$field.TsType}};
      {{end -}}
    {{ end -}}
  {{end}}
}

export interface {{.Node}}EditInput {
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      {{$field.TsFieldName}}?: {{$field.TsType}};
    {{ end -}}
  {{end}}
}

function defaultValue (key: string, property: string): any {
  let fn = {{$baseClass}}.getField(key)?.[property];
  if (!fn) {
    return null;
  }
  return fn();
};

export async function create{{.Node}}From<T extends {{$baseClass}}>(
  viewer: Viewer, 
  input: {{.Node}}CreateInput,
  {{$constructor}},
  ): Promise<T | null> {
  let fields  = {
    {{range $field := .FieldInfo.Fields -}}
      {{ if $field.EditableField -}}
        "{{$field.GetDbColName}}": input.{{$field.TsFieldName}},
      {{ else if $field.HasDefaultValueOnCreate -}}
        "{{$field.GetDbColName}}": defaultValue("{{$field.FieldName}}", "defaultValueOnCreate"),
      {{end -}}
    {{end -}}
  };

  return await createEnt(
    viewer, 
    {
      tableName: tableName,
      fields: fields,
      ent: arg,
    }
  );
}

export async function edit{{.Node}}From<T extends {{$baseClass}}>(
  viewer: Viewer, 
  id: ID, 
  input: {{.Node}}EditInput,
  {{$constructor}},
): Promise<T | null> {
  const setField = function(key: string, value: any) {
    if (value !== undefined) { // nullable fields allowed
      fields[key] = value;
    }
  };
  let fields  = {
    {{range $field := .FieldInfo.Fields -}}
      {{ if $field.HasDefaultValueOnEdit -}}
        "{{$field.GetDbColName}}": defaultValue("{{$field.FieldName}}", "defaultValueOnEdit"),
      {{end -}}
    {{end -}}
  };
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      setField("{{$field.GetDbColName}}", input.{{$field.TsFieldName}});
    {{end -}}
  {{end}}

  return await editEnt(
    viewer,
    id,
    {
      tableName: tableName,
      fields: fields,
      ent: arg,
    }
  );
}

export async function delete{{.Node}}(viewer: Viewer, id: ID): Promise<null> {
  return await deleteEnt(
    viewer,
    id,
    {
      tableName: tableName,
    }
  );
};
{{end -}}