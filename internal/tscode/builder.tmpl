{{reserveImport .Package.PackagePath "Viewer" "ID" "Ent" "AssocEdgeInputOptions"}}
{{reserveImport .Package.ActionPackagePath "Action" "Builder" "WriteOperation" "Changeset" "saveBuilder" "saveBuilderX" "Orchestrator"}}

{{ $cfg := .CodePath -}}
{{ $schema := .Schema -}}

{{with .NodeData -}}
{{ $schemaPath := .GetSchemaPath }}
{{ reserveDefaultImport $schemaPath "schema"}}
{{ reserveImport "src/ent/generated/const" "EdgeType" "NodeType" }}
{{$loaderInfo := printf "%sLoaderInfo" .NodeInstance -}}
{{ reserveImport "src/ent/generated/loaders" $loaderInfo -}}


{{ range .GetImportPathsForDependencies $schema -}}
  {{ reserveImportPath . true}}
{{ end}}

{{$builder := printf "%sBuilder" .Node}}
{{$input := printf "%sInput" .Node}}

export interface {{$input}} {
  {{range $field := .FieldInfo.GetEditableFields -}}
    {{$type := $field.TsBuilderType $cfg -}}
      {{range $field.TsBuilderImports $cfg -}}
        {{ reserveImportPath . true -}}
        {{ $ignore := useImport .Import -}}
      {{end -}}
    {{$field.TsBuilderFieldName}}?: {{$type}};
  {{end -}}
  // allow other properties. useful for action-only fields
  [x: string]: any;
}

{{/* TODO better way of doing this? */}}
function randomNum(): string {
  return Math.random()
    .toString(10)
    .substring(2);
}

{{$node := useImport .Node}}

{{$viewerInfo := $cfg.GetTemplatizedViewer -}}
{{ reserveImport $viewerInfo.Path $viewerInfo.Name -}}
{{$viewerType := useImport $viewerInfo.Name -}}

{{$mixinInfo := .GetBuilderMixinInfo $schema -}}
{{$hasBuilderMixin := $mixinInfo.Imports -}}
{{ if $hasBuilderMixin -}}
  class Base {
    // @ts-ignore not assigning. need for Mixin
    orchestrator: {{useImport "Orchestrator"}}<{{$node}}, any, {{$viewerType}}>;

    constructor() {}

    isBuilder<T extends {{useImport "Ent"}}>(
      node: {{useImport "ID"}} | T | {{useImport "Builder"}}<T, any>,
    ): node is {{useImport "Builder"}}<T, any> {
      return (node as {{useImport "Builder"}}<T, any>).placeholderID !== undefined;
    }
  }
{{ end}}

type MaybeNull<T extends Ent> = T | null;
type TMaybleNullableEnt<T extends Ent> = T | MaybeNull<T>;

export class {{$builder}}<
  TInput extends {{$input}} = {{$input}},
  TExistingEnt extends TMaybleNullableEnt<{{$node}}> = {{$node}} | null,
> 

{{ if $hasBuilderMixin }}
  {{ range $mixinInfo.Imports -}}
    {{ $ignore := useImport .Import -}}
  {{end -}}
  extends {{$mixinInfo.Extends }}
{{ end -}}

implements {{useImport "Builder"}}<{{$node}}, {{$viewerType}}, TExistingEnt> {
  orchestrator: {{useImport "Orchestrator"}}<{{$node}}, TInput, {{$viewerType}}, TExistingEnt>;
  readonly placeholderID: {{useImport "ID"}};
  readonly ent = {{$node}};
  readonly nodeType = {{useImport "NodeType"}}.{{$node}};
  private input: TInput;
  private m: Map<string, any> = new Map();

  public constructor(
    public readonly viewer: {{$viewerType}},
    public readonly operation: {{useImport "WriteOperation"}},
    action: {{useImport "Action"}}<{{$node}}, {{useImport "Builder"}}<{{$node}}, {{$viewerType}}, TExistingEnt>, {{$viewerType}}, TInput, TExistingEnt>,
    public readonly existingEnt: TExistingEnt,
  ) {
    {{ if $hasBuilderMixin }}
      super();
    {{ end -}}
    this.placeholderID = `$ent.idPlaceholderID$ ${randomNum()}-{{$node}}`;
    this.input = action.getInput();
    const updateInput = (d: {{$input}}) => this.updateInput.apply(this, [d]);

    this.orchestrator = new {{useImport "Orchestrator"}}({
      viewer,
      operation: this.operation,
      tableName: "{{.TableName}}", 
      key: "id",
      loaderOptions: {{$node}}.loaderOptions(),
      builder: this,
      action,
      {{useImport "schema"}},
      editedFields: () => this.getEditedFields.apply(this),
      updateInput,
      fieldInfo: {{useImport $loaderInfo}}.fieldInfo,
    });
  }

  getInput(): TInput {
    return this.input;
  }

  updateInput(input: {{$input}}) {
    // override input
    this.input = {
      ...this.input,
      ...input,
    };
  }

  deleteInputKey(key: keyof {{.Node}}Input) {
    delete this.input[key];
  }

  // store data in Builder that can be retrieved by another validator, trigger, observer later in the action
  storeData(k: string, v: any) {
    this.m.set(k, v);
  }

  // retrieve data stored in this Builder with key
  getStoredData(k: string) {
    return this.m.get(k);
  }

  {{if .HasAssociationEdges -}}
    // this gets the inputs that have been written for a given edgeType and operation
    // WriteOperation.Insert for adding an edge and WriteOperation.Delete for deleting an edge
    getEdgeInputData(edgeType: {{useImport "EdgeType"}}, op: {{useImport "WriteOperation"}}) {
      return this.orchestrator.getInputEdges(edgeType, op);
    }

    clearInputEdges(edgeType: {{useImport "EdgeType"}}, op: {{useImport "WriteOperation"}}, id?: {{useImport "ID"}}) {
      this.orchestrator.clearInputEdges(edgeType, op, id);
    }
  {{end -}}

  {{ template "edge_builder.tmpl" .BuilderEdges $schema -}}

  async build(): Promise<{{useImport "Changeset"}}> {
    return this.orchestrator.build();
  }

  async valid(): Promise<boolean> {
    return this.orchestrator.valid();
  }

  async validX(): Promise<void> {
    return this.orchestrator.validX();
  }

  async save(): Promise<void> {
    await {{useImport "saveBuilder"}}(this);
  }

  async saveX(): Promise<void> {
    await {{useImport "saveBuilderX"}}(this);
  }

  async editedEnt(): Promise<{{$node}} | null> {
    {{/* TODO: throw if save() has not been called */ -}}
    return this.orchestrator.editedEnt();
  }

  async editedEntX(): Promise<{{$node}}> {
    {{/* TODO: throw if saveX() has not been called */ -}}
    return this.orchestrator.editedEntX();
  }

  private async getEditedFields(): Promise<Map<string, any>> {
    const fields = this.input;

    const result = new Map<string, any>();

    const addField = function(key: string, value: any) {
      if (value !== undefined) {
        result.set(key, value);
      }
    };
    {{range $field := .FieldInfo.GetEditableFields -}}
      {{$tsFieldName := $field.TsBuilderFieldName -}}
      addField("{{$field.FieldName}}", fields.{{$tsFieldName}});
      {{ $inverseEdge := $field.GetInverseEdge -}}
      {{ if $inverseEdge -}}
        if (fields.{{$tsFieldName}} !== undefined) {
          if (fields.{{$tsFieldName}}) {
            this.orchestrator.addInboundEdge(
              fields.{{$tsFieldName}},
              {{useImport "EdgeType"}}.{{$inverseEdge.TsEdgeConst}},
              {{useImport "NodeType"}}.{{$inverseEdge.NodeInfo.Node}},
            );
          }
          {{ if $field.HasAsyncAccessor $cfg -}}
            // can't have this be dependent on privacy so need to fetch the raw data...
            if (this.existingEnt) {
              {{/* TODO eventually this needs to be smart enough and parallelize with any other possible fields here */ -}}
              const rawData = await {{$node}}.loadRawData(this.existingEnt.id, this.viewer.context);
              if (rawData && rawData.{{$field.GetDbColName}} !== null && rawData.{{$field.GetDbColName}} !== undefined) {
                this.orchestrator.removeInboundEdge(
                  rawData.{{$field.GetDbColName}},
                  {{useImport "EdgeType"}}.{{$inverseEdge.TsEdgeConst}},
                );
              }
            }
          {{ else -}}
            if (this.existingEnt && this.existingEnt.{{$tsFieldName}} && this.existingEnt.{{$tsFieldName}} !== fields.{{$tsFieldName}}) {
              this.orchestrator.removeInboundEdge(
                this.existingEnt.{{$tsFieldName}},
                {{useImport "EdgeType"}}.{{$inverseEdge.TsEdgeConst}},
              );
            }
          {{ end -}}
        }
      {{end -}}
    {{end -}}
    return result;
  }

  isBuilder<T extends {{useImport "Ent"}}>(node: ID | T | Builder<T, any>): node is Builder<T, any> {
    return (node as Builder<T, any>).placeholderID !== undefined;
  }

  {{range $field := .FieldInfo.GetEditableFields}}
    {{$tsFieldName := $field.TsBuilderFieldName -}}
    // get value of {{$field.FieldName}}. Retrieves it from the input if specified or takes it from existingEnt
    getNew{{$field.CamelCaseName}}Value(): {{$field.TsBuilderUnionType $cfg}} | undefined {
    {{/** hmm not ideal for these accessors to not work...*/}}
      {{if $field.Private $cfg -}}
        return this.input.{{$tsFieldName}};
      {{else -}}
        if (this.input.{{$tsFieldName}} !== undefined) {
          return this.input.{{$tsFieldName}}
        }
        return this.existingEnt?.{{$tsFieldName}};
      {{end -}}
    }

  {{end}}
}

{{end -}}
