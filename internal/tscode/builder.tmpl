{{reserveImport .Package.PackagePath "Viewer" "ID" "Ent" "AssocEdgeInputOptions"}}
{{reserveImport .Package.ActionPackagePath "Action" "Builder" "WriteOperation" "Changeset" "saveBuilder" "saveBuilderX" "Orchestrator"}}

{{ $cfg := .CodePath -}}

{{with .NodeData -}}
{{ $schemaPath := .GetSchemaPath }}
{{ reserveDefaultImport $schemaPath "schema"}}
{{ reserveImport "src/ent/generated/const" "EdgeType" "NodeType" }}
{{$loaderInfo := printf "%sLoaderInfo" .NodeInstance -}}
{{ reserveImport "src/ent/generated/loaders" $loaderInfo -}}


{{ range .GetImportPathsForDependencies -}}
  {{ reserveImportPath . true}}
{{ end}}

{{$builder := printf "%sBuilder" .Node}}
{{$input := printf "%sInput" .Node}}

export interface {{$input}} {
  {{range $field := .FieldInfo.GetEditableFields -}}
    {{$type := $field.TsBuilderType $cfg -}}
      {{range $field.TsBuilderImports $cfg -}}
        {{ reserveImportPath . true -}}
        {{ $ignore := useImport .Import -}}
      {{end -}}
    {{$field.TsBuilderFieldName}}?: {{$type}};
  {{end -}}
  // allow other properties. useful for action-only fields
  [x: string]: any;
}

{{/* TODO better way of doing this? */}}
function randomNum(): string {
  return Math.random()
    .toString(10)
    .substring(2);
}

{{$node := useImport .Node}}

type MaybeNull<T extends Ent> = T | null;
type TMaybleNullableEnt<T extends Ent> = T | MaybeNull<T>;

{{$viewerInfo := $cfg.GetTemplatizedViewer -}}
{{ reserveImport $viewerInfo.Path $viewerInfo.Name -}}
{{$viewerType := useImport $viewerInfo.Name -}}

export class {{$builder}}<
  TInput extends {{$input}} = {{$input}},
  TExistingEnt extends TMaybleNullableEnt<{{$node}}> = {{$node}} | null,
> implements {{useImport "Builder"}}<{{$node}}, {{$viewerType}}, TExistingEnt> {
  orchestrator: {{useImport "Orchestrator"}}<{{$node}}, TInput, {{$viewerType}}, TExistingEnt>;
  readonly placeholderID: {{useImport "ID"}};
  readonly ent = {{$node}};
  readonly nodeType = {{useImport "NodeType"}}.{{$node}};
  private input: TInput;
  private m: Map<string, any> = new Map();

  public constructor(
    public readonly viewer: {{$viewerType}},
    public readonly operation: {{useImport "WriteOperation"}},
    action: {{useImport "Action"}}<{{$node}}, {{useImport "Builder"}}<{{$node}}, {{$viewerType}}, TExistingEnt>, {{$viewerType}}, TInput, TExistingEnt>,
    public readonly existingEnt: TExistingEnt,
  ) {
    this.placeholderID = `$ent.idPlaceholderID$ ${randomNum()}-{{$node}}`;
    this.input = action.getInput();
    const updateInput = (d: {{$input}}) => this.updateInput.apply(this, [d]);

    this.orchestrator = new {{useImport "Orchestrator"}}({
      viewer,
      operation: this.operation,
      tableName: "{{.TableName}}", 
      key: "id",
      loaderOptions: {{$node}}.loaderOptions(),
      builder: this,
      action,
      {{useImport "schema"}},
      editedFields: () => this.getEditedFields.apply(this),
      updateInput,
      fieldInfo: {{useImport $loaderInfo}}.fieldInfo,
    });
  }

  getInput(): TInput {
    return this.input;
  }

  updateInput(input: {{$input}}) {
    // override input
    this.input = {
      ...this.input,
      ...input,
    };
  }

  deleteInputKey(key: keyof {{.Node}}Input) {
    delete this.input[key];
  }

  // store data in Builder that can be retrieved by another validator, trigger, observer later in the action
  storeData(k: string, v: any) {
    this.m.set(k, v);
  }

  // retrieve data stored in this Builder with key
  getStoredData(k: string) {
    return this.m.get(k);
  }

  {{if .HasAssociationEdges -}}
    // this gets the inputs that have been written for a given edgeType and operation
    // WriteOperation.Insert for adding an edge and WriteOperation.Delete for deleting an edge
    getEdgeInputData(edgeType: {{useImport "EdgeType"}}, op: {{useImport "WriteOperation"}}) {
      return this.orchestrator.getInputEdges(edgeType, op);
    }

    clearInputEdges(edgeType: {{useImport "EdgeType"}}, op: {{useImport "WriteOperation"}}, id?: {{useImport "ID"}}) {
      this.orchestrator.clearInputEdges(edgeType, op, id);
    }
  {{end -}}

  {{ $edgeInfos := edgeInfos .EdgeInfo.Associations -}}
  {{ range $edge := $edgeInfos -}}  
    {{ $node := useImport .Node -}}
    {{ $polymorphicEdge := $edge.Edge.PolymorphicEdge -}}
  {{ if $polymorphicEdge -}}
    {{$edge.TSAddMethodName}}(...nodes: ({{$node}} | Builder<{{$node}}, any>)[]): {{$builder}}<TInput, TExistingEnt> {
  {{ else -}}
  {{/* for PolymorphicEdges, this API doesn't work since we don't know the type. callers should call addLikerID in a map */}}  
    {{$edge.TSAddMethodName}}(...nodes: (ID | {{$node}} | Builder<{{$node}}, any>)[]): {{$builder}}<TInput, TExistingEnt> {
  {{ end -}}
    for (const node of nodes) {
      {{ if $polymorphicEdge -}}
        if (this.isBuilder(node)) {
          this.orchestrator.addOutboundEdge(
            node, 
            {{useImport "EdgeType"}}.{{$edge.TSEdgeConst}},
            // nodeType will be gotten from Executor later
            "",
          );
        } else {
          this.orchestrator.addOutboundEdge(
            node.id, 
            {{useImport "EdgeType"}}.{{$edge.TSEdgeConst}},
            node.nodeType,
          );
        }
      {{ else -}}
        if (this.isBuilder(node)) {
          this.{{$edge.TSAddIDMethodName}}(node);
        } else if (typeof node === "object") {
          this.{{$edge.TSAddIDMethodName}}(node.id);
        } else {
          this.{{$edge.TSAddIDMethodName}}(node);
        }
      {{ end -}}
    }
    return this;
  }

  {{$edge.TSAddIDMethodName}}(
    id: {{useImport "ID"}} | Builder<{{$node}}, any>, 
    {{ if $polymorphicEdge -}}
      nodeType: {{useImport "NodeType"}},
    {{ end -}}
    options?: {{useImport "AssocEdgeInputOptions"}}
  ): {{$builder}}<TInput, TExistingEnt> {
    {{/* TODO need inbound edges also */}}
    this.orchestrator.addOutboundEdge(
      id, 
      {{useImport "EdgeType"}}.{{$edge.TSEdgeConst}},
      {{ if $polymorphicEdge -}}
        nodeType,
      {{ else -}}
        {{useImport "NodeType"}}.{{.Node}},
      {{end -}}
      options,
    );
    return this;
  }

  {{$edge.TSRemoveMethodName}}(...nodes: (ID | {{$node}})[]): {{$builder}}<TInput, TExistingEnt> {
    for (const node of nodes) {
      if (typeof node === "object") {
        this.orchestrator.removeOutboundEdge(node.id, {{useImport "EdgeType"}}.{{$edge.TSEdgeConst}});
      } else {
        this.orchestrator.removeOutboundEdge(node, {{useImport "EdgeType"}}.{{$edge.TSEdgeConst}});
      }
    }
    return this;
  }

  {{end -}}


  async build(): Promise<{{useImport "Changeset"}}> {
    return this.orchestrator.build();
  }

  async valid(): Promise<boolean> {
    return this.orchestrator.valid();
  }

  async validX(): Promise<void> {
    return this.orchestrator.validX();
  }

  async save(): Promise<void> {
    await {{useImport "saveBuilder"}}(this);
  }

  async saveX(): Promise<void> {
    await {{useImport "saveBuilderX"}}(this);
  }

  async editedEnt(): Promise<{{$node}} | null> {
    {{/* TODO: throw if save() has not been called */ -}}
    return this.orchestrator.editedEnt();
  }

  async editedEntX(): Promise<{{$node}}> {
    {{/* TODO: throw if saveX() has not been called */ -}}
    return this.orchestrator.editedEntX();
  }

  private async getEditedFields(): Promise<Map<string, any>> {
    const fields = this.input;

    const result = new Map<string, any>();

    const addField = function(key: string, value: any) {
      if (value !== undefined) {
        result.set(key, value);
      }
    };
    {{range $field := .FieldInfo.GetEditableFields -}}
      {{$tsFieldName := $field.TsBuilderFieldName -}}
      addField("{{$field.FieldName}}", fields.{{$tsFieldName}});
      {{ $inverseEdge := $field.GetInverseEdge -}}
      {{ if $inverseEdge -}}
        if (fields.{{$tsFieldName}} !== undefined) {
          if (fields.{{$tsFieldName}}) {
            this.orchestrator.addInboundEdge(
              fields.{{$tsFieldName}},
              {{useImport "EdgeType"}}.{{$inverseEdge.TsEdgeConst}},
              {{useImport "NodeType"}}.{{$inverseEdge.NodeInfo.Node}},
            );
          }
          {{ if $field.HasAsyncAccessor $cfg -}}
            // can't have this be dependent on privacy so need to fetch the raw data...
            if (this.existingEnt) {
              {{/* TODO eventually this needs to be smart enough and parallelize with any other possible fields here */ -}}
              const rawData = await {{$node}}.loadRawData(this.existingEnt.id, this.viewer.context);
              if (rawData && rawData.{{$field.GetDbColName}} !== null && rawData.{{$field.GetDbColName}} !== undefined) {
                this.orchestrator.removeInboundEdge(
                  rawData.{{$field.GetDbColName}},
                  {{useImport "EdgeType"}}.{{$inverseEdge.TsEdgeConst}},
                );
              }
            }
          {{ else -}}
            if (this.existingEnt && this.existingEnt.{{$tsFieldName}} && this.existingEnt.{{$tsFieldName}} !== fields.{{$tsFieldName}}) {
              this.orchestrator.removeInboundEdge(
                this.existingEnt.{{$tsFieldName}},
                {{useImport "EdgeType"}}.{{$inverseEdge.TsEdgeConst}},
              );
            }
          {{ end -}}
        }
      {{end -}}
    {{end -}}
    return result;
  }

  isBuilder<T extends {{useImport "Ent"}}>(node: ID | T | Builder<T, any>): node is Builder<T, any> {
    return (node as Builder<T, any>).placeholderID !== undefined;
  }

  {{range $field := .FieldInfo.GetEditableFields}}
    {{$tsFieldName := $field.TsBuilderFieldName -}}
    // get value of {{$field.FieldName}}. Retrieves it from the input if specified or takes it from existingEnt
    getNew{{$field.CamelCaseName}}Value(): {{$field.TsBuilderUnionType $cfg}} | undefined {
    {{/** hmm not ideal for these accessors to not work...*/}}
      {{if $field.Private $cfg -}}
        return this.input.{{$tsFieldName}};
      {{else -}}
        if (this.input.{{$tsFieldName}} !== undefined) {
          return this.input.{{$tsFieldName}}
        }
        return this.existingEnt?.{{$tsFieldName}};
      {{end -}}
    }

  {{end}}
}

{{end -}}
