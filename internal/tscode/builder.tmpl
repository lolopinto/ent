{{with .NodeData -}}

{{reserveImport "ent/ent" "Viewer" "ID" "Ent" "AssocEdgeInputOptions"}}
{{reserveImport "ent/action" "Action" "Builder" "WriteOperation" "Changeset"}}
{{reserveImport "ent/orchestrator" "Orchestrator"}}

{{ $schemaPath := printf "src/schema/%s" .PackageName }}
{{ reserveDefaultImport $schemaPath "schema"}}
{{ reserveImport "src/ent/const" "EdgeType" "NodeType" }}

{{ range .GetUniqueNodesForceSelf -}} 
  {{$packagePath := printf "src/ent/%s" .PackageName }}
  {{ reserveDefaultImport $packagePath .Node}}
{{ end}}

export interface {{.Node}}Input {
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      {{$type := $field.TsType -}}
      {{/* TODO make this generic to work for all imported types but this is hack for ID for now */ -}}
      {{ if eq $type "ID" -}}
        {{ $type = useImport "ID" -}}
      {{end -}}
      {{$field.TsFieldName}}?: {{$type}};
    {{end -}}
  {{end -}}
  requiredFields: string[];
}

export interface {{.Node}}Action extends {{useImport "Action"}}<{{useImport .Node}}> {
  getFields(): {{.Node}}Input;
}

{{/* TODO better way of doing this? */}}
function randomNum(): string {
  return Math.random()
    .toString(10)
    .substring(2);
}

{{$node := useImport .Node}}
{{$builder := printf "%sBuilder" .Node}}

export class {{$builder}} implements {{useImport "Builder"}}<{{$node}}> {
  private orchestrator: {{useImport "Orchestrator"}}<{{$node}}>;
  readonly placeholderID: {{useImport "ID"}};
  readonly ent = {{$node}};

  public constructor(
    public readonly viewer: {{useImport "Viewer"}},
    public readonly operation: {{useImport "WriteOperation"}},
    private action: {{.Node}}Action,
    public readonly existingEnt?: {{$node}} | undefined,
  ) {
    this.placeholderID = `$ent.idPlaceholderID$ ${randomNum()}`;

    this.orchestrator = new {{useImport "Orchestrator"}}({
      viewer: viewer,
      operation: this.operation,
      tableName: "{{.TableName}}", 
      ent: {{$node}},
      builder: this,
      action: action,
      schema: {{useImport "schema"}},
      editedFields: () => {
        return this.getEditedFields.apply(this);
      },
    });
  }

  getInput(): {{.Node}}Input {
    return this.action.getFields();
  }

  private getEditedFields(): Map<string, any> {
    const fields = this.action.getFields();

    // required fields
    let m = {};
    let result = new Map<string, any>();
    for (const field of fields.requiredFields) {
      m[field] = true;
    }

    const addField = function(key: string, value: any, setNull: boolean) {
      if (value !== undefined) {
        result.set(key, value);
      } else if (setNull) {
        result.set(key, null);
      }
    };
    {{range $field := .FieldInfo.Fields -}}
      {{ if $field.EditableField -}}
        {{$tsFieldName := $field.TsFieldName -}}
        addField("{{$field.FieldName}}", fields.{{$tsFieldName}}, m["{{$field.FieldName}}"]);
        {{ $inverseEdge := $field.GetInverseEdge -}}
        {{ if $inverseEdge -}}
          if (fields.{{$tsFieldName}}) {
            this.orchestrator.addInboundEdge(
              fields.{{$tsFieldName}},
              {{useImport "EdgeType"}}.{{$inverseEdge.TsEdgeConst}},
              {{useImport "NodeType"}}.{{$inverseEdge.NodeInfo.Node}},
            );
          }
        {{end -}}
      {{end -}}
    {{end -}}
    return result;
  }

  {{ $edgeInfos := .EdgeInfo.Associations -}}
  {{ range $edge := $edgeInfos -}}  
  add{{$edge.Singular}}(...ids: {{useImport "ID"}}[]): {{$builder}};
  add{{$edge.Singular}}(...nodes: {{useImport .NodeInfo.Node}}[]): {{$builder}};
  add{{$edge.Singular}}(...nodes: ID[] | {{.NodeInfo.Node}}[]): {{$builder}} {
    for (const node of nodes) {
      if (typeof node === "object") {
        this.add{{$edge.Singular}}ID(node.id);
      } else {
        this.add{{$edge.Singular}}ID(node);
      }
    }
    return this;
  }

  add{{$edge.Singular}}ID(id: {{useImport "ID"}}, options?: {{useImport "AssocEdgeInputOptions"}}): {{$builder}} {
    {{/* TODO need inbound edges also */}}
    this.orchestrator.addOutboundEdge(
      id, 
      {{useImport "EdgeType"}}.{{$edge.TsEdgeConst}},
      {{useImport "NodeType"}}.{{.NodeInfo.Node}},
      options,
    );
    return this;
  }

  remove{{$edge.Singular}}(...ids: {{useImport "ID"}}[]): {{$builder}};
  remove{{$edge.Singular}}(...nodes: {{useImport .NodeInfo.Node}}[]): {{$builder}};
  remove{{$edge.Singular}}(...nodes: ID[] | {{.NodeInfo.Node}}[]): {{$builder}} {
    for (const node of nodes) {
      if (typeof node === "object") {
        this.orchestrator.removeOutboundEdge(node.id, {{useImport "EdgeType"}}.{{$edge.TsEdgeConst}});
      } else {
        this.orchestrator.removeOutboundEdge(node, {{useImport "EdgeType"}}.{{$edge.TsEdgeConst}});
      }
    }
    return this;
  }

  {{end -}}


  async build(): Promise<{{useImport "Changeset"}}<{{$node}}>> {
    return this.orchestrator.build();
  }

  async valid(): Promise<boolean> {
    return this.orchestrator.valid();
  }

  async validX(): Promise<void> {
    return this.orchestrator.validX();
  }
}

{{end -}}
