{{with .NodeData -}}

{{reserveImport "ent/ent" "Viewer" "ID" "Ent" "AssocEdgeInputOptions"}}
{{reserveImport "ent/action" "Action" "Builder" "WriteOperation" "Changeset" "saveBuilder" "saveBuilderX" }}
{{reserveImport "ent/orchestrator" "Orchestrator"}}

{{ $schemaPath := printf "src/schema/%s" .PackageName }}
{{ reserveDefaultImport $schemaPath "schema"}}
{{ reserveImport "src/ent/const" "EdgeType" "NodeType" }}

{{ range .GetUniqueNodesForceSelf -}} 
  {{$packagePath := printf "src/ent/%s" .PackageName }}
  {{ reserveDefaultImport $packagePath .Node}}
{{ end}}

export interface {{.Node}}Input {
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      {{$type := $field.TsBuilderType -}}
        {{range $import := $field.TsBuilderImports -}}
          {{ $ignore := useImport $import -}}
        {{end -}}
      {{$field.TsFieldName}}?: {{$type}};
    {{end -}}
  {{end -}}
}

export interface {{.Node}}Action extends {{useImport "Action"}}<{{useImport .Node}}> {
  getInput(): {{.Node}}Input;
}

{{/* TODO better way of doing this? */}}
function randomNum(): string {
  return Math.random()
    .toString(10)
    .substring(2);
}

{{$node := useImport .Node}}
{{$builder := printf "%sBuilder" .Node}}

export class {{$builder}} implements {{useImport "Builder"}}<{{$node}}> {
  private orchestrator: {{useImport "Orchestrator"}}<{{$node}}>;
  readonly placeholderID: {{useImport "ID"}};
  readonly ent = {{$node}};
  private input: {{.Node}}Input;

  public constructor(
    public readonly viewer: {{useImport "Viewer"}},
    public readonly operation: {{useImport "WriteOperation"}},
    private action: {{.Node}}Action,
    public readonly existingEnt?: {{$node}} | undefined,
  ) {
    this.placeholderID = `$ent.idPlaceholderID$ ${randomNum()}`;
    this.input = action.getInput();

    this.orchestrator = new {{useImport "Orchestrator"}}({
      viewer: viewer,
      operation: this.operation,
      tableName: "{{.TableName}}", 
      ent: {{$node}},
      builder: this,
      action: action,
      schema: {{useImport "schema"}},
      editedFields: () => {
        return this.getEditedFields.apply(this);
      },
    });
  }

  getInput(): {{.Node}}Input {
    return this.input;
  }

  updateInput(input: {{.Node}}Input) {
    // override input
    this.input = {
      ...this.input,
      ...input,
    };
  }

  {{ $edgeInfos := .EdgeInfo.Associations -}}
  {{ range $edge := $edgeInfos -}}  
    {{ $node := useImport .NodeInfo.Node -}}
  add{{$edge.Singular}}(...ids: {{useImport "ID"}}[]): {{$builder}};
  add{{$edge.Singular}}(...nodes: {{$node}}[]): {{$builder}};
  add{{$edge.Singular}}(...nodes: Builder<{{$node}}>[]): {{$builder}};
  add{{$edge.Singular}}(...nodes: ID[] | {{$node}}[] | Builder<{{$node}}>[]): {{$builder}} {
    for (const node of nodes) {
      if (this.is{{$node}}Builder(node)) {
        this.add{{$edge.Singular}}ID(node);
      } else if (typeof node === "object") {
        this.add{{$edge.Singular}}ID(node.id);
      } else {
        this.add{{$edge.Singular}}ID(node);
      }
    }
    return this;
  }

  add{{$edge.Singular}}ID(id: {{useImport "ID"}} | Builder<{{$node}}>, options?: {{useImport "AssocEdgeInputOptions"}}): {{$builder}} {
    {{/* TODO need inbound edges also */}}
    this.orchestrator.addOutboundEdge(
      id, 
      {{useImport "EdgeType"}}.{{$edge.TsEdgeConst}},
      {{useImport "NodeType"}}.{{.NodeInfo.Node}},
      options,
    );
    return this;
  }

  remove{{$edge.Singular}}(...ids: {{useImport "ID"}}[]): {{$builder}};
  remove{{$edge.Singular}}(...nodes: {{useImport .NodeInfo.Node}}[]): {{$builder}};
  remove{{$edge.Singular}}(...nodes: ID[] | {{.NodeInfo.Node}}[]): {{$builder}} {
    for (const node of nodes) {
      if (typeof node === "object") {
        this.orchestrator.removeOutboundEdge(node.id, {{useImport "EdgeType"}}.{{$edge.TsEdgeConst}});
      } else {
        this.orchestrator.removeOutboundEdge(node, {{useImport "EdgeType"}}.{{$edge.TsEdgeConst}});
      }
    }
    return this;
  }

  {{end -}}


  async build(): Promise<{{useImport "Changeset"}}<{{$node}}>> {
    return this.orchestrator.build();
  }

  async valid(): Promise<boolean> {
    return this.orchestrator.valid();
  }

  async validX(): Promise<void> {
    return this.orchestrator.validX();
  }

  async save(): Promise<void> {
    await {{useImport "saveBuilder"}}(this);
  }

  async saveX(): Promise<void> {
    await {{useImport "saveBuilderX"}}(this);
  }

  async editedEnt(): Promise<{{$node}} | null> {
    {{/* TODO: throw if save() has not been called */ -}}
    return await this.orchestrator.editedEnt();
  }

  async editedEntX(): Promise<{{$node}}> {
    {{/* TODO: throw if saveX() has not been called */ -}}
    return await this.orchestrator.editedEntX();
  }

  private getEditedFields(): Map<string, any> {
    const fields = this.input;

    let result = new Map<string, any>();

    const addField = function(key: string, value: any) {
      if (value !== undefined) {
        result.set(key, value);
      }
    };
    {{range $field := .FieldInfo.Fields -}}
      {{ if $field.EditableField -}}
        {{$tsFieldName := $field.TsFieldName -}}
        addField("{{$field.FieldName}}", fields.{{$tsFieldName}});
        {{ $inverseEdge := $field.GetInverseEdge -}}
        {{ if $inverseEdge -}}
          if (fields.{{$tsFieldName}}) {
            this.orchestrator.addInboundEdge(
              fields.{{$tsFieldName}},
              {{useImport "EdgeType"}}.{{$inverseEdge.TsEdgeConst}},
              {{useImport "NodeType"}}.{{$inverseEdge.NodeInfo.Node}},
            );
          }
        {{end -}}
      {{end -}}
    {{end -}}
    return result;
  }

  {{ range .GetUniqueNodes -}} 
    private is{{.Node}}Builder(node: ID | {{.Node}} | Builder<{{.Node}}>): node is Builder<{{.Node}}> {
      return (node as Builder<{{.Node}}>).placeholderID !== undefined;
    }

  {{end}}

}

{{end -}}
