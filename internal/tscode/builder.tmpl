{{reserveImport .Package.PackagePath "Viewer" "ID" "Ent" "AssocEdgeInputOptions"}}
{{reserveImport .Package.ActionPackagePath "Action" "Builder" "WriteOperation" "Changeset" "saveBuilder" "saveBuilderX" "Orchestrator"}}

{{with .NodeData -}}
{{ $schemaPath := printf "src/schema/%s" .PackageName }}
{{ reserveDefaultImport $schemaPath "schema"}}
{{ reserveImport "src/ent/generated/const" "EdgeType" "NodeType" }}


{{ range .GetImportPathsForDependencies -}}
  {{ if .DefaultImport -}}
    {{ reserveDefaultImport .PackagePath .Import}}
  {{ else -}}
    {{ reserveImport .PackagePath .Import}}
  {{ end -}}
{{ end}}

{{$builder := printf "%sBuilder" .Node}}
{{$input := printf "%sInput" .Node}}

export interface {{$input}} {
  {{range $field := .FieldInfo.GetEditableFields -}}
    {{$type := $field.TsBuilderType -}}
      {{range $import := $field.TsBuilderImports -}}
        {{ $ignore := useImport $import -}}
      {{end -}}
    {{$field.TsFieldName}}?: {{$type}};
  {{end -}}
  // allow other properties. useful for action-only fields
  [x: string]: any;
}

{{/* TODO better way of doing this? */}}
function randomNum(): string {
  return Math.random()
    .toString(10)
    .substring(2);
}

{{$node := useImport .Node}}

export class {{$builder}}<TData extends {{$input}} = {{$input}}> implements {{useImport "Builder"}}<{{$node}}> {
  orchestrator: {{useImport "Orchestrator"}}<{{$node}}, TData>;
  readonly placeholderID: {{useImport "ID"}};
  readonly ent = {{$node}};
  readonly nodeType = {{useImport "NodeType"}}.{{$node}};
  private input: TData;
  private m: Map<string, any> = new Map();

  public constructor(
    public readonly viewer: {{useImport "Viewer"}},
    public readonly operation: {{useImport "WriteOperation"}},
    action: {{useImport "Action"}}<{{$node}}, {{useImport "Builder"}}<{{$node}}>, TData>,
    public readonly existingEnt?: {{$node}} | undefined,
  ) {
    this.placeholderID = `$ent.idPlaceholderID$ ${randomNum()}-{{$node}}`;
    this.input = action.getInput();
    const updateInput = (d: {{$input}}) => this.updateInput.apply(this, [d]);

    this.orchestrator = new {{useImport "Orchestrator"}}({
      viewer,
      operation: this.operation,
      tableName: "{{.TableName}}", 
      key: "id",
      loaderOptions: {{$node}}.loaderOptions(),
      builder: this,
      action,
      {{useImport "schema"}},
      editedFields: () => this.getEditedFields.apply(this),
      updateInput,
    });
  }

  getInput(): TData {
    return this.input;
  }

  updateInput(input: {{$input}}) {
    // override input
    this.input = {
      ...this.input,
      ...input,
    };
  }

  // store data in Builder that can be retrieved by another validator, trigger, observer later in the action
  storeData(k: string, v: any) {
    this.m.set(k, v);
  }

  // retrieve data stored in this Builder with key
  getStoredData(k: string) {
    return this.m.get(k);
  }

  {{if .HasAssociationEdges -}}
    // this gets the inputs that have been written for a given edgeType and operation
    // WriteOperation.Insert for adding an edge and WriteOperation.Delete for deleting an edge
    getEdgeInputData(edgeType: {{useImport "EdgeType"}}, op: {{useImport "WriteOperation"}}) {
      return this.orchestrator.getInputEdges(edgeType, op);
    }

    clearInputEdges(edgeType: {{useImport "EdgeType"}}, op: {{useImport "WriteOperation"}}, id?: {{useImport "ID"}}) {
      this.orchestrator.clearInputEdges(edgeType, op, id);
    }
  {{end -}}

  {{ $edgeInfos := edgeInfos .EdgeInfo.Associations -}}
  {{ range $edge := $edgeInfos -}}  
    {{ $node := useImport .Node -}}
    {{ $polymorphicEdge := $edge.Edge.PolymorphicEdge -}}
  {{ if $polymorphicEdge -}}
    {{$edge.TSAddMethodName}}(...nodes: ({{$node}} | Builder<{{$node}}>)[]): {{$builder}}<TData> {
  {{ else -}}
  {{/* for PolymorphicEdges, this API doesn't work since we don't know the type. callers should call addLikerID in a map */}}  
    {{$edge.TSAddMethodName}}(...nodes: (ID | {{$node}} | Builder<{{$node}}>)[]): {{$builder}}<TData> {
  {{ end -}}
    for (const node of nodes) {
      {{ if $polymorphicEdge -}}
        if (this.isBuilder(node)) {
          this.orchestrator.addOutboundEdge(
            node, 
            {{useImport "EdgeType"}}.{{$edge.TSEdgeConst}},
            // nodeType will be gotten from Executor later
            "",
          );
        } else {
          this.orchestrator.addOutboundEdge(
            node.id, 
            {{useImport "EdgeType"}}.{{$edge.TSEdgeConst}},
            node.nodeType,
          );
        }
      {{ else -}}
        if (this.isBuilder(node)) {
          this.{{$edge.TSAddIDMethodName}}(node);
        } else if (typeof node === "object") {
          this.{{$edge.TSAddIDMethodName}}(node.id);
        } else {
          this.{{$edge.TSAddIDMethodName}}(node);
        }
      {{ end -}}
    }
    return this;
  }

  {{$edge.TSAddIDMethodName}}(
    id: {{useImport "ID"}} | Builder<{{$node}}>, 
    {{ if $polymorphicEdge -}}
      nodeType: {{useImport "NodeType"}},
    {{ end -}}
    options?: {{useImport "AssocEdgeInputOptions"}}
  ): {{$builder}}<TData> {
    {{/* TODO need inbound edges also */}}
    this.orchestrator.addOutboundEdge(
      id, 
      {{useImport "EdgeType"}}.{{$edge.TSEdgeConst}},
      {{ if $polymorphicEdge -}}
        nodeType,
      {{ else -}}
        {{useImport "NodeType"}}.{{.Node}},
      {{end -}}
      options,
    );
    return this;
  }

  {{$edge.TSRemoveMethodName}}(...nodes: (ID | {{$node}})[]): {{$builder}}<TData> {
    for (const node of nodes) {
      if (typeof node === "object") {
        this.orchestrator.removeOutboundEdge(node.id, {{useImport "EdgeType"}}.{{$edge.TSEdgeConst}});
      } else {
        this.orchestrator.removeOutboundEdge(node, {{useImport "EdgeType"}}.{{$edge.TSEdgeConst}});
      }
    }
    return this;
  }

  {{end -}}


  async build(): Promise<{{useImport "Changeset"}}<{{$node}}>> {
    return this.orchestrator.build();
  }

  async valid(): Promise<boolean> {
    return this.orchestrator.valid();
  }

  async validX(): Promise<void> {
    return this.orchestrator.validX();
  }

  async save(): Promise<void> {
    await {{useImport "saveBuilder"}}(this);
  }

  async saveX(): Promise<void> {
    await {{useImport "saveBuilderX"}}(this);
  }

  async editedEnt(): Promise<{{$node}} | null> {
    {{/* TODO: throw if save() has not been called */ -}}
    return this.orchestrator.editedEnt();
  }

  async editedEntX(): Promise<{{$node}}> {
    {{/* TODO: throw if saveX() has not been called */ -}}
    return this.orchestrator.editedEntX();
  }

  private getEditedFields(): Map<string, any> {
    const fields = this.input;

    const result = new Map<string, any>();

    const addField = function(key: string, value: any) {
      if (value !== undefined) {
        result.set(key, value);
      }
    };
    {{range $field := .FieldInfo.GetEditableFields -}}
      {{$tsFieldName := $field.TsFieldName -}}
      addField("{{$field.FieldName}}", fields.{{$tsFieldName}});
      {{ $inverseEdge := $field.GetInverseEdge -}}
      {{ if $inverseEdge -}}
        if (fields.{{$tsFieldName}} !== undefined) {
          if (fields.{{$tsFieldName}}) {
            this.orchestrator.addInboundEdge(
              fields.{{$tsFieldName}},
              {{useImport "EdgeType"}}.{{$inverseEdge.TsEdgeConst}},
              {{useImport "NodeType"}}.{{$inverseEdge.NodeInfo.Node}},
            );
          }
          if (this.existingEnt && this.existingEnt.{{$tsFieldName}} && this.existingEnt.{{$tsFieldName}} !== fields.{{$tsFieldName}}) {
            this.orchestrator.removeInboundEdge(
              this.existingEnt.{{$tsFieldName}},
              {{useImport "EdgeType"}}.{{$inverseEdge.TsEdgeConst}},
            );
          }
        }
      {{end -}}
    {{end -}}
    return result;
  }

  isBuilder(node: ID | {{useImport "Ent"}} | Builder<{{useImport "Ent"}}>): node is Builder<{{useImport "Ent"}}> {
    return (node as Builder<{{useImport "Ent"}}>).placeholderID !== undefined;
  }

  {{range $field := .FieldInfo.GetEditableFields}}
    // get value of {{$field.FieldName}}. Retrieves it from the input if specified or takes it from existingEnt
    getNew{{$field.CamelCaseName}}Value(): {{$field.TsBuilderType}} | undefined {
      {{if $field.Private -}}
        return this.input.{{$field.TsFieldName}};
      {{else -}}
        if (this.input.{{$field.TsFieldName}} !== undefined) {
          return this.input.{{$field.TsFieldName}}
        }
        return this.existingEnt?.{{$field.TsFieldName}};
      {{end -}}
    }

  {{end}}
}

{{end -}}
