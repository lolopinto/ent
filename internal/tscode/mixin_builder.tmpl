{{ reserveTypeImport .Package.PackagePath "ID" "Ent" "Data" "AssocEdgeInputOptions" }}
{{reserveTypeImport .Package.ActionPackagePath "Action" "Builder" "Changeset" "Orchestrator"}}

{{$p := .Pattern}}
{{ $cfg := .Config -}}
{{ $schema := .Schema -}}
{{ $pkg := .Package -}}

{{ reserveImport "src/ent/generated/types" "EdgeType" "NodeType" }}

{{$viewerInfo := $cfg.GetTemplatizedViewer -}}
{{ reserveTypeImportPath $viewerInfo.GetImportPath false -}}
{{$viewerType := useTypeImport $viewerInfo.GetImport -}}
{{ reserveTypeImport .Package.InternalImportPath $p.GetMixinInterfaceName -}}

{{ range .Imports }}
  {{reserveImportPath . false}}
{{ end}}

export interface {{$p.GetBuilderInterfaceName}}<T extends {{useTypeImport $p.GetMixinInterfaceName}}> {
  {{/* if the logic in here changes, also have to update edge_builder.tmpl */ -}}
  {{ $edgeInfos := edgeInfos $p.GetSortedEdges -}}
  {{ range $edge := $edgeInfos -}}  
    {{ $node := useTypeImportMaybe .Node -}}
    {{ $polymorphicEdge := $edge.Edge.PolymorphicEdge -}}
    {{ if $polymorphicEdge -}}
      {{$edge.TSAddMethodName}}(...nodes: ({{$node}} | {{useTypeImport "Builder"}}<{{$node}}, any>)[]): this;
    {{ else -}}
    {{/* for PolymorphicEdges, this API doesn't work since we don't know the type. callers should call addLikerID in a map */}}  
      {{$edge.TSAddMethodName}}(...nodes: ({{useTypeImport "ID"}} | {{$node}} | {{useTypeImport "Builder"}}<{{$node}}, any>)[]): this;
    {{ end -}}
    {{$edge.TSAddIDMethodName}}(
      id: {{useTypeImport "ID"}} | {{useTypeImport "Builder"}}<{{$node}}, any>, 
      {{ if $polymorphicEdge -}}
        nodeType: {{useImport "NodeType"}},
      {{ end -}}
      options?: {{useTypeImport "AssocEdgeInputOptions"}}
    ): this;
    {{$edge.TSRemoveMethodName}}(...nodes: ({{useTypeImport "ID"}} | {{$node}})[]): this;
  {{end -}}
}

{{$builderName := printf "%sIsh" $p.GetBuilderName }}

// come back
type Constructor<T extends {{$p.GetMixinInterfaceName}}<{{$viewerType}}> = {{$p.GetMixinInterfaceName}}<{{$viewerType}}>> = new (...args: any[]) => T;

interface BuilderConstructor<T extends {{$p.GetMixinInterfaceName}}<{{$viewerType}}>, C = {}> {
  orchestrator: {{useTypeImport "Orchestrator"}}<T, any, {{$viewerType}}>;
  isBuilder<T extends {{useTypeImport "Ent"}}>(
    node: {{useTypeImport "ID"}} | T | {{useTypeImport "Builder"}}<T, any>,
  ): node is {{useTypeImport "Builder"}}<T, any>;
};

{{$ishName := printf "%sIsh" $p.GetBuilderName -}} 

export type {{$ishName}}<T extends {{$p.GetMixinInterfaceName}}<{{$viewerType}}>> = Constructor<
  // @ts-ignore TODO fix
  BuilderConstructor<T>
>;


export function {{$p.GetBuilderName}}<
  TEnt extends {{$p.GetMixinInterfaceName}}<{{$viewerType}}>,
  TBase extends {{$ishName}}<TEnt>,
>(BaseClass: TBase) {
  return class {{$p.GetBuilderName}}
    extends BaseClass
    implements {{$p.GetBuilderInterfaceName}}<TEnt>
  {
    constructor(...args: any[]) {
      super(...args);
    }

  {{ template "edge_builder.tmpl" (dict "Edges" $p.GetSortedEdges "Schema" $schema "Package" $pkg) -}}
  }
}
