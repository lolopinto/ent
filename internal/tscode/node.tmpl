import {loadEnt, ID, Viewer, loadEntX, LoadEntOptions, createEnt, editEnt, deleteEnt} from "../../../../src/ent";
import {Field, getFields} from "../../../../src/schema";
import schema from './../schema/{{.NodeData.PackageName}}';

{{with .NodeData -}}
const tableName = "{{.TableName}}";

export default class {{.Node}} {

  {{range $field := .FieldInfo.Fields -}}
    readonly {{$field.TsFieldName}}: {{$field.TsType}};
  {{end}}

  constructor(viewer: Viewer, id: ID, options:{}) {
    this.id = id;
    // TODO don't double read id
    {{range $field := .FieldInfo.Fields -}}
      this.{{$field.TsFieldName}} = options['{{$field.GetDbColName}}'];
    {{end}}
  }

  static async load(viewer: Viewer, id: ID): Promise<{{.Node}} | null>{
    return loadEnt(viewer, id, {{.Node}}.getOptions());
  }

  static async loadX(viewer: Viewer, id: ID): Promise<{{.Node}}> {
    return loadEntX(viewer, id, {{.Node}}.getOptions());
  }

  private static getFields(): string[] {
    return [
    {{range $field := .FieldInfo.Fields -}}
      '{{$field.GetDbColName}}',
    {{end}}
    ];
  }

  private static schemaFields: Map<string,Field>;

  private static getSchemaFields(): Map<string, Field> {
    if ({{.Node}}.schemaFields != null) {
      return {{.Node}}.schemaFields;
    }
    return {{.Node}}.schemaFields = getFields(schema);
  }

  static getField(key: string): Field | undefined{
    return {{.Node}}.getSchemaFields().get(key);
  }

  private static getOptions(): LoadEntOptions<{{.Node}}> {
    return {
      tableName: tableName,
      fields: {{.Node}}.getFields(),
      ent: {{.Node}},
    };
  }
}

// no actions yet so we support full create, edit, delete for now
export interface {{.Node}}CreateInput {
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      {{/* if nullable or has default value, make it optional */ -}}
      {{if or $field.Nullable $field.HasDefaultValueOnCreate -}}
        {{$field.TsFieldName}}?: {{$field.TsType}};
      {{else -}}
        {{$field.TsFieldName}}: {{$field.TsType}};
      {{end -}}
    {{ end -}}
  {{end}}
}

export interface {{.Node}}EditInput {
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      {{$field.TsFieldName}}?: {{$field.TsType}};
    {{ end -}}
  {{end}}
}

function defaultValue (key: string, property: string): any {
  let fn = {{.Node}}.getField(key)?.[property];
  if (!fn) {
    return null;
  }
  return fn();
};

export async function create{{.Node}}(viewer: Viewer, input: {{.Node}}CreateInput): Promise<{{.Node}} | null> {
  let fields  = {
    {{range $field := .FieldInfo.Fields -}}
      {{ if $field.EditableField -}}
        "{{$field.GetDbColName}}": input.{{$field.TsFieldName}},
      {{ else if $field.HasDefaultValueOnCreate -}}
        "{{$field.GetDbColName}}": defaultValue("{{$field.FieldName}}", "defaultValueOnCreate"),
      {{end -}}
    {{end -}}
  };

  return await createEnt(
    viewer, 
    {
      tableName: tableName,
      fields: fields,
      ent: {{.Node}},
    }
  );
}

export async function edit{{.Node}}(viewer: Viewer, id: ID, input: {{.Node}}EditInput): Promise<{{.Node}} | null> {
  const setField = function(key: string, value: any) {
    if (value !== undefined) { // nullable fields allowed
      fields[key] = value;
    }
  };
  let fields  = {
    {{range $field := .FieldInfo.Fields -}}
      {{ if $field.HasDefaultValueOnEdit -}}
        "{{$field.GetDbColName}}": defaultValue("{{$field.FieldName}}", "defaultValueOnEdit"),
      {{end -}}
    {{end -}}
  };
  {{range $field := .FieldInfo.Fields -}}
    {{ if $field.EditableField -}}
      setField("{{$field.GetDbColName}}", input.{{$field.TsFieldName}});
    {{end -}}
  {{end}}

  return await editEnt(
    viewer,
    id,
    {
      tableName: tableName,
      fields: fields,
      ent: {{.Node}},
    }
  );
}

export async function delete{{.Node}}(viewer: Viewer, id: ID): Promise<null> {
  return await deleteEnt(
    viewer,
    id,
    {
      tableName: tableName,
    }
  );
};
{{end -}}