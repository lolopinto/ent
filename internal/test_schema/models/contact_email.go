// Code generated by github.com/lolopinto/ent/ent, DO NOT edit.

package models

import (
	"context"
	"sync"

	"github.com/lolopinto/ent/ent"
	"github.com/lolopinto/ent/ent/cast"
	"github.com/lolopinto/ent/ent/viewer"

	"github.com/lolopinto/ent/internal/test_schema/models/configs"
)

const (
	// ContactEmailType is the node type for the ContactEmail object. Used to identify this node in edges and other places.
	ContactEmailType ent.NodeType = "contactEmail"
)

// ContactEmail represents the `ContactEmail` model
type ContactEmail struct {
	ent.Node
	EmailAddress string `db:"email_address"`
	Label        string `db:"label"`
	ContactID    string `db:"contact_id"`
	Viewer       viewer.ViewerContext
}

// ContactEmailResult stores the result of loading a ContactEmail. It's a tuple type which has 2 fields:
// a ContactEmail and an error
type ContactEmailResult struct {
	ContactEmail *ContactEmail
	Error        error
}

// ContactEmailsResult stores the result of loading a slice of ContactEmails. It's a tuple type which has 2 fields:
// a []*ContactEmail and an error
type ContactEmailsResult struct {
	ContactEmails []*ContactEmail
	Error         error
}

// IsNode is needed by gqlgen to indicate that this implements the Node interface in GraphQL
func (contactEmail ContactEmail) IsNode() {}

// GetType returns the NodeType of this entity. In this case: ContactType
func (contactEmail *ContactEmail) GetType() ent.NodeType {
	return ContactEmailType
}

// GetViewer returns the viewer for this entity.
func (contactEmail *ContactEmail) GetViewer() viewer.ViewerContext {
	return contactEmail.Viewer
}

// GetPrivacyPolicy returns the PrivacyPolicy of this entity.
func (contactEmail *ContactEmail) GetPrivacyPolicy() ent.PrivacyPolicy {
	return ContactEmailPrivacyPolicy{
		ContactEmail: contactEmail,
	}
}

// LoadContactEmailFromContext loads the given ContactEmail given the context and id
func LoadContactEmailFromContext(ctx context.Context, id string) (*ContactEmail, error) {
	v, err := viewer.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	return LoadContactEmail(v, id)
}

// LoadContactEmail loads the given ContactEmail given the viewer and id
func LoadContactEmail(viewer viewer.ViewerContext, id string) (*ContactEmail, error) {
	var contactEmail ContactEmail
	err := ent.LoadNode(viewer, id, &contactEmail, &configs.ContactEmailConfig{})
	return &contactEmail, err
}

// GenLoadContactEmail loads the given ContactEmail given the id
func GenLoadContactEmail(viewer viewer.ViewerContext, id string, result *ContactEmailResult, wg *sync.WaitGroup) {
	defer wg.Done()
	var contactEmail ContactEmail
	chanErr := make(chan error)
	go ent.GenLoadNode(viewer, id, &contactEmail, &configs.ContactEmailConfig{}, chanErr)
	err := <-chanErr
	result.ContactEmail = &contactEmail
	result.Error = err
}

// GenContact returns the Contact associated with the ContactEmail instance
func (contactEmail *ContactEmail) GenContact(result *ContactResult, wg *sync.WaitGroup) {
	go GenLoadContact(contactEmail.Viewer, contactEmail.ContactID, result, wg)
}

// LoadContact returns the Contact associated with the ContactEmail instance
func (contactEmail *ContactEmail) LoadContact() (*Contact, error) {
	return LoadContact(contactEmail.Viewer, contactEmail.ContactID)
}

// DBFields is used by the ent framework to load the ent from the underlying database
func (contactEmail *ContactEmail) DBFields() ent.DBFields {
	return ent.DBFields{
		"id": func(v interface{}) error {
			var err error
			contactEmail.ID, err = cast.ToUUIDString(v)
			return err
		},
		"email_address": func(v interface{}) error {
			var err error
			contactEmail.EmailAddress, err = cast.ToString(v)
			return err
		},
		"label": func(v interface{}) error {
			var err error
			contactEmail.Label, err = cast.ToString(v)
			return err
		},
		"contact_id": func(v interface{}) error {
			var err error
			contactEmail.ContactID, err = cast.ToString(v)
			return err
		},
	}
}

var _ ent.Entity = &ContactEmail{}
