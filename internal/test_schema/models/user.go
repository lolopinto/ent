// Code generated by github.com/lolopinto/ent/ent, DO NOT edit.

package models

import (
	"context"
	"sync"

	"github.com/lolopinto/ent/ent"
	"github.com/lolopinto/ent/ent/cast"
	"github.com/lolopinto/ent/ent/viewer"

	"github.com/lolopinto/ent/internal/test_schema/models/configs"
)

const (
	// UserType is the node type for the User object. Used to identify this node in edges and other places.
	UserType ent.NodeType = "user"

	// UserToDeclinedEventsEdge is the edgeType for the user to declinedevents edge.
	UserToDeclinedEventsEdge ent.EdgeType = "14f2d5b4-d0fd-4088-ba25-e417ab40307c"
	// UserToEventsAttendingEdge is the edgeType for the user to eventsattending edge.
	UserToEventsAttendingEdge ent.EdgeType = "4afef8fc-f75a-406e-aafc-8b571980e6ef"
	// UserToEventsEdge is the edgeType for the user to events edge.
	UserToEventsEdge ent.EdgeType = "41bddf81-0c26-432c-9133-2f093af2c07c"
	// UserToFamilyMembersEdge is the edgeType for the user to familymembers edge.
	UserToFamilyMembersEdge ent.EdgeType = "38176101-6adc-4e0d-bd36-08cdc45f5ed2"
	// UserToFriendsEdge is the edgeType for the user to friends edge.
	UserToFriendsEdge ent.EdgeType = "d78d13dc-85d6-4f55-a72d-5dbcdc36131d"
	// UserToInvitedEventsEdge is the edgeType for the user to invitedevents edge.
	UserToInvitedEventsEdge ent.EdgeType = "e89302ca-c76b-41ad-a823-9e3964b821dd"
)

// User represents the `User` model
type User struct {
	ent.Node
	EmailAddress string  `db:"email_address"`
	FirstName    string  `db:"first_name"`
	LastName     string  `db:"last_name"`
	Bio          *string `db:"bio"`
	Viewer       viewer.ViewerContext
}

// UserResult stores the result of loading a User. It's a tuple type which has 2 fields:
// a User and an error
type UserResult struct {
	User  *User
	Error error
}

// UsersResult stores the result of loading a slice of Users. It's a tuple type which has 2 fields:
// a []*User and an error
type UsersResult struct {
	Users []*User
	Error error
}

// IsNode is needed by gqlgen to indicate that this implements the Node interface in GraphQL
func (user User) IsNode() {}

// GetType returns the NodeType of this entity. In this case: ContactType
func (user *User) GetType() ent.NodeType {
	return UserType
}

// GetViewer returns the viewer for this entity.
func (user *User) GetViewer() viewer.ViewerContext {
	return user.Viewer
}

// GetPrivacyPolicy returns the PrivacyPolicy of this entity.
func (user *User) GetPrivacyPolicy() ent.PrivacyPolicy {
	return UserPrivacyPolicy{
		User: user,
	}
}

// LoadUserFromContext loads the given User given the context and id
func LoadUserFromContext(ctx context.Context, id string) (*User, error) {
	v, err := viewer.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	return LoadUser(v, id)
}

// LoadUser loads the given User given the viewer and id
func LoadUser(viewer viewer.ViewerContext, id string) (*User, error) {
	var user User
	err := ent.LoadNode(viewer, id, &user, &configs.UserConfig{})
	return &user, err
}

// GenLoadUser loads the given User given the id
func GenLoadUser(viewer viewer.ViewerContext, id string, result *UserResult, wg *sync.WaitGroup) {
	defer wg.Done()
	var user User
	chanErr := make(chan error)
	go ent.GenLoadNode(viewer, id, &user, &configs.UserConfig{}, chanErr)
	err := <-chanErr
	result.User = &user
	result.Error = err
}

// GenContacts returns the Contacts associated with the User instance
func (user *User) GenContacts(result *ContactsResult, wg *sync.WaitGroup) {
	defer wg.Done()
	var contacts []*Contact
	chanErr := make(chan error)
	go ent.GenLoadForeignKeyNodes(user.Viewer, user.ID, &contacts, "user_id", &configs.ContactConfig{}, chanErr)
	err := <-chanErr
	result.Contacts = contacts
	result.Error = err
}

// LoadContacts returns the Contacts associated with the User instance
func (user *User) LoadContacts() ([]*Contact, error) {
	var contacts []*Contact
	err := ent.LoadForeignKeyNodes(user.Viewer, user.ID, &contacts, "user_id", &configs.ContactConfig{})
	return contacts, err
}

// LoadEventsEdges returns the Events edges associated with the User instance
func (user *User) LoadEventsEdges() ([]*ent.Edge, error) {
	return ent.LoadEdgesByType(user.ID, UserToEventsEdge)
}

// GenEventsEdges returns the Event edges associated with the User instance
func (user *User) GenEventsEdges(result *ent.EdgesResult, wg *sync.WaitGroup) {
	defer wg.Done()
	edgesResultChan := make(chan ent.EdgesResult)
	go ent.GenLoadEdgesByType(user.ID, UserToEventsEdge, edgesResultChan)
	*result = <-edgesResultChan
}

// GenEvents returns the Events associated with the User instance
func (user *User) GenEvents(result *EventsResult, wg *sync.WaitGroup) {
	defer wg.Done()
	var events []*Event
	chanErr := make(chan error)
	go ent.GenLoadNodesByType(user.Viewer, user.ID, UserToEventsEdge, &events, &configs.EventConfig{}, chanErr)
	err := <-chanErr
	result.Events = events
	result.Error = err
}

// LoadEvents returns the Events associated with the User instance
func (user *User) LoadEvents() ([]*Event, error) {
	var events []*Event
	err := ent.LoadNodesByType(user.Viewer, user.ID, UserToEventsEdge, &events, &configs.EventConfig{})
	return events, err
}

// LoadEventsEdgeFor loads the ent.Edge between the current node and the given id2 for the Events edge.
func (user *User) LoadEventsEdgeFor(id2 string) (*ent.Edge, error) {
	return ent.LoadEdgeByType(user.ID, id2, UserToEventsEdge)
}

// GenEventsEdgeFor provides a concurrent API to load the ent.Edge between the current node and the given id2 for the Events edge.
func (user *User) GenLoadEventsEdgeFor(id2 string, result *ent.EdgeResult, wg *sync.WaitGroup) {
	defer wg.Done()
	edgeResultChan := make(chan ent.EdgeResult)
	go ent.GenLoadEdgeByType(user.ID, id2, UserToEventsEdge, edgeResultChan)
	*result = <-edgeResultChan
}

// LoadFamilyMembersEdges returns the FamilyMembers edges associated with the User instance
func (user *User) LoadFamilyMembersEdges() ([]*ent.Edge, error) {
	return ent.LoadEdgesByType(user.ID, UserToFamilyMembersEdge)
}

// GenFamilyMembersEdges returns the User edges associated with the User instance
func (user *User) GenFamilyMembersEdges(result *ent.EdgesResult, wg *sync.WaitGroup) {
	defer wg.Done()
	edgesResultChan := make(chan ent.EdgesResult)
	go ent.GenLoadEdgesByType(user.ID, UserToFamilyMembersEdge, edgesResultChan)
	*result = <-edgesResultChan
}

// GenFamilyMembers returns the Users associated with the User instance
func (user *User) GenFamilyMembers(result *UsersResult, wg *sync.WaitGroup) {
	defer wg.Done()
	var users []*User
	chanErr := make(chan error)
	go ent.GenLoadNodesByType(user.Viewer, user.ID, UserToFamilyMembersEdge, &users, &configs.UserConfig{}, chanErr)
	err := <-chanErr
	result.Users = users
	result.Error = err
}

// LoadFamilyMembers returns the Users associated with the User instance
func (user *User) LoadFamilyMembers() ([]*User, error) {
	var users []*User
	err := ent.LoadNodesByType(user.Viewer, user.ID, UserToFamilyMembersEdge, &users, &configs.UserConfig{})
	return users, err
}

// LoadFamilyMembersEdgeFor loads the ent.Edge between the current node and the given id2 for the FamilyMembers edge.
func (user *User) LoadFamilyMembersEdgeFor(id2 string) (*ent.Edge, error) {
	return ent.LoadEdgeByType(user.ID, id2, UserToFamilyMembersEdge)
}

// GenFamilyMembersEdgeFor provides a concurrent API to load the ent.Edge between the current node and the given id2 for the FamilyMembers edge.
func (user *User) GenLoadFamilyMembersEdgeFor(id2 string, result *ent.EdgeResult, wg *sync.WaitGroup) {
	defer wg.Done()
	edgeResultChan := make(chan ent.EdgeResult)
	go ent.GenLoadEdgeByType(user.ID, id2, UserToFamilyMembersEdge, edgeResultChan)
	*result = <-edgeResultChan
}

// LoadFriendsEdges returns the Friends edges associated with the User instance
func (user *User) LoadFriendsEdges() ([]*ent.Edge, error) {
	return ent.LoadEdgesByType(user.ID, UserToFriendsEdge)
}

// GenFriendsEdges returns the User edges associated with the User instance
func (user *User) GenFriendsEdges(result *ent.EdgesResult, wg *sync.WaitGroup) {
	defer wg.Done()
	edgesResultChan := make(chan ent.EdgesResult)
	go ent.GenLoadEdgesByType(user.ID, UserToFriendsEdge, edgesResultChan)
	*result = <-edgesResultChan
}

// GenFriends returns the Users associated with the User instance
func (user *User) GenFriends(result *UsersResult, wg *sync.WaitGroup) {
	defer wg.Done()
	var users []*User
	chanErr := make(chan error)
	go ent.GenLoadNodesByType(user.Viewer, user.ID, UserToFriendsEdge, &users, &configs.UserConfig{}, chanErr)
	err := <-chanErr
	result.Users = users
	result.Error = err
}

// LoadFriends returns the Users associated with the User instance
func (user *User) LoadFriends() ([]*User, error) {
	var users []*User
	err := ent.LoadNodesByType(user.Viewer, user.ID, UserToFriendsEdge, &users, &configs.UserConfig{})
	return users, err
}

// LoadFriendsEdgeFor loads the ent.Edge between the current node and the given id2 for the Friends edge.
func (user *User) LoadFriendsEdgeFor(id2 string) (*ent.Edge, error) {
	return ent.LoadEdgeByType(user.ID, id2, UserToFriendsEdge)
}

// GenFriendsEdgeFor provides a concurrent API to load the ent.Edge between the current node and the given id2 for the Friends edge.
func (user *User) GenLoadFriendsEdgeFor(id2 string, result *ent.EdgeResult, wg *sync.WaitGroup) {
	defer wg.Done()
	edgeResultChan := make(chan ent.EdgeResult)
	go ent.GenLoadEdgeByType(user.ID, id2, UserToFriendsEdge, edgeResultChan)
	*result = <-edgeResultChan
}

// LoadInvitedEventsEdges returns the InvitedEvents edges associated with the User instance
func (user *User) LoadInvitedEventsEdges() ([]*ent.Edge, error) {
	return ent.LoadEdgesByType(user.ID, UserToInvitedEventsEdge)
}

// GenInvitedEventsEdges returns the Event edges associated with the User instance
func (user *User) GenInvitedEventsEdges(result *ent.EdgesResult, wg *sync.WaitGroup) {
	defer wg.Done()
	edgesResultChan := make(chan ent.EdgesResult)
	go ent.GenLoadEdgesByType(user.ID, UserToInvitedEventsEdge, edgesResultChan)
	*result = <-edgesResultChan
}

// GenInvitedEvents returns the Events associated with the User instance
func (user *User) GenInvitedEvents(result *EventsResult, wg *sync.WaitGroup) {
	defer wg.Done()
	var events []*Event
	chanErr := make(chan error)
	go ent.GenLoadNodesByType(user.Viewer, user.ID, UserToInvitedEventsEdge, &events, &configs.EventConfig{}, chanErr)
	err := <-chanErr
	result.Events = events
	result.Error = err
}

// LoadInvitedEvents returns the Events associated with the User instance
func (user *User) LoadInvitedEvents() ([]*Event, error) {
	var events []*Event
	err := ent.LoadNodesByType(user.Viewer, user.ID, UserToInvitedEventsEdge, &events, &configs.EventConfig{})
	return events, err
}

// LoadInvitedEventsEdgeFor loads the ent.Edge between the current node and the given id2 for the InvitedEvents edge.
func (user *User) LoadInvitedEventsEdgeFor(id2 string) (*ent.Edge, error) {
	return ent.LoadEdgeByType(user.ID, id2, UserToInvitedEventsEdge)
}

// GenInvitedEventsEdgeFor provides a concurrent API to load the ent.Edge between the current node and the given id2 for the InvitedEvents edge.
func (user *User) GenLoadInvitedEventsEdgeFor(id2 string, result *ent.EdgeResult, wg *sync.WaitGroup) {
	defer wg.Done()
	edgeResultChan := make(chan ent.EdgeResult)
	go ent.GenLoadEdgeByType(user.ID, id2, UserToInvitedEventsEdge, edgeResultChan)
	*result = <-edgeResultChan
}

// LoadEventsAttendingEdges returns the EventsAttending edges associated with the User instance
func (user *User) LoadEventsAttendingEdges() ([]*ent.Edge, error) {
	return ent.LoadEdgesByType(user.ID, UserToEventsAttendingEdge)
}

// GenEventsAttendingEdges returns the Event edges associated with the User instance
func (user *User) GenEventsAttendingEdges(result *ent.EdgesResult, wg *sync.WaitGroup) {
	defer wg.Done()
	edgesResultChan := make(chan ent.EdgesResult)
	go ent.GenLoadEdgesByType(user.ID, UserToEventsAttendingEdge, edgesResultChan)
	*result = <-edgesResultChan
}

// GenEventsAttending returns the Events associated with the User instance
func (user *User) GenEventsAttending(result *EventsResult, wg *sync.WaitGroup) {
	defer wg.Done()
	var events []*Event
	chanErr := make(chan error)
	go ent.GenLoadNodesByType(user.Viewer, user.ID, UserToEventsAttendingEdge, &events, &configs.EventConfig{}, chanErr)
	err := <-chanErr
	result.Events = events
	result.Error = err
}

// LoadEventsAttending returns the Events associated with the User instance
func (user *User) LoadEventsAttending() ([]*Event, error) {
	var events []*Event
	err := ent.LoadNodesByType(user.Viewer, user.ID, UserToEventsAttendingEdge, &events, &configs.EventConfig{})
	return events, err
}

// LoadEventsAttendingEdgeFor loads the ent.Edge between the current node and the given id2 for the EventsAttending edge.
func (user *User) LoadEventsAttendingEdgeFor(id2 string) (*ent.Edge, error) {
	return ent.LoadEdgeByType(user.ID, id2, UserToEventsAttendingEdge)
}

// GenEventsAttendingEdgeFor provides a concurrent API to load the ent.Edge between the current node and the given id2 for the EventsAttending edge.
func (user *User) GenLoadEventsAttendingEdgeFor(id2 string, result *ent.EdgeResult, wg *sync.WaitGroup) {
	defer wg.Done()
	edgeResultChan := make(chan ent.EdgeResult)
	go ent.GenLoadEdgeByType(user.ID, id2, UserToEventsAttendingEdge, edgeResultChan)
	*result = <-edgeResultChan
}

// LoadDeclinedEventsEdges returns the DeclinedEvents edges associated with the User instance
func (user *User) LoadDeclinedEventsEdges() ([]*ent.Edge, error) {
	return ent.LoadEdgesByType(user.ID, UserToDeclinedEventsEdge)
}

// GenDeclinedEventsEdges returns the Event edges associated with the User instance
func (user *User) GenDeclinedEventsEdges(result *ent.EdgesResult, wg *sync.WaitGroup) {
	defer wg.Done()
	edgesResultChan := make(chan ent.EdgesResult)
	go ent.GenLoadEdgesByType(user.ID, UserToDeclinedEventsEdge, edgesResultChan)
	*result = <-edgesResultChan
}

// GenDeclinedEvents returns the Events associated with the User instance
func (user *User) GenDeclinedEvents(result *EventsResult, wg *sync.WaitGroup) {
	defer wg.Done()
	var events []*Event
	chanErr := make(chan error)
	go ent.GenLoadNodesByType(user.Viewer, user.ID, UserToDeclinedEventsEdge, &events, &configs.EventConfig{}, chanErr)
	err := <-chanErr
	result.Events = events
	result.Error = err
}

// LoadDeclinedEvents returns the Events associated with the User instance
func (user *User) LoadDeclinedEvents() ([]*Event, error) {
	var events []*Event
	err := ent.LoadNodesByType(user.Viewer, user.ID, UserToDeclinedEventsEdge, &events, &configs.EventConfig{})
	return events, err
}

// LoadDeclinedEventsEdgeFor loads the ent.Edge between the current node and the given id2 for the DeclinedEvents edge.
func (user *User) LoadDeclinedEventsEdgeFor(id2 string) (*ent.Edge, error) {
	return ent.LoadEdgeByType(user.ID, id2, UserToDeclinedEventsEdge)
}

// GenDeclinedEventsEdgeFor provides a concurrent API to load the ent.Edge between the current node and the given id2 for the DeclinedEvents edge.
func (user *User) GenLoadDeclinedEventsEdgeFor(id2 string, result *ent.EdgeResult, wg *sync.WaitGroup) {
	defer wg.Done()
	edgeResultChan := make(chan ent.EdgeResult)
	go ent.GenLoadEdgeByType(user.ID, id2, UserToDeclinedEventsEdge, edgeResultChan)
	*result = <-edgeResultChan
}

// DBFields is used by the ent framework to load the ent from the underlying database
func (user *User) DBFields() ent.DBFields {
	return ent.DBFields{
		"id": func(v interface{}) error {
			var err error
			user.ID, err = cast.ToUUIDString(v)
			return err
		},
		"email_address": func(v interface{}) error {
			var err error
			user.EmailAddress, err = cast.ToString(v)
			return err
		},
		"first_name": func(v interface{}) error {
			var err error
			user.FirstName, err = cast.ToString(v)
			return err
		},
		"last_name": func(v interface{}) error {
			var err error
			user.LastName, err = cast.ToString(v)
			return err
		},
		"bio": func(v interface{}) error {
			var err error
			user.Bio, err = cast.ToNullableString(v)
			return err
		},
	}
}

var _ ent.Entity = &User{}
