// Code generated by github.com/lolopinto/ent/ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"sync"
	"time"

	"github.com/lolopinto/ent/ent"
	"github.com/lolopinto/ent/ent/cast"
	"github.com/lolopinto/ent/ent/privacy"
	"github.com/lolopinto/ent/ent/viewer"
	"github.com/lolopinto/ent/internal/test_schema/models/configs"
)

type EventRsvpStatus string

const (
	// EventType is the node type for the Event object. Used to identify this node in edges and other places.
	EventType ent.NodeType = "event"

	// EventToAttendingEdge is the edgeType for the event to attending edge.
	EventToAttendingEdge ent.EdgeType = "9f384bf7-af59-4a41-8b67-8ecc659524c6"
	// EventToCreatorEdge is the edgeType for the event to creator edge.
	EventToCreatorEdge ent.EdgeType = "eb45df04-a2ce-4d20-9325-ef6ddb7c5c31"
	// EventToDeclinedEdge is the edgeType for the event to declined edge.
	EventToDeclinedEdge ent.EdgeType = "d7b9e19a-4214-4376-927c-58b98913dbb7"
	// EventToHostsEdge is the edgeType for the event to hosts edge.
	EventToHostsEdge ent.EdgeType = "06a23665-6e2c-413a-bbb0-f53222c313dd"
	// EventToInvitedEdge is the edgeType for the event to invited edge.
	EventToInvitedEdge ent.EdgeType = "12a5ac62-1f9a-4fd7-b38f-a6d229ace12c"

	// EventAttending is the edge representing the status for the Attending edge.
	EventAttending EventRsvpStatus = "event_attending"
	// EventDeclined is the edge representing the status for the Declined edge.
	EventDeclined EventRsvpStatus = "event_declined"
	// EventInvited is the edge representing the status for the Invited edge.
	EventInvited EventRsvpStatus = "event_invited"
	// EventUnknown is the edge representing the unknown status for the RsvpStatus edgegroup.
	EventUnknown EventRsvpStatus = "event_unknown"
)

// Event represents the `Event` model
type Event struct {
	ent.Node
	privacy.AlwaysDenyPrivacyPolicy
	Name      string     `db:"name"`
	UserID    string     `db:"user_id"`
	StartTime time.Time  `db:"start_time"`
	EndTime   *time.Time `db:"end_time"`
	Location  string     `db:"location"`
	Viewer    viewer.ViewerContext
}

//  type Events map[string]Event

// EventResult stores the result of loading a Event. It's a tuple type which has 2 fields:
// a Event and an error
type EventResult struct {
	Event *Event
	Err   error
}

func (res *EventResult) Error() string {
	return res.Err.Error()
}

// EventsResult stores the result of loading a slice of Events. It's a tuple type which has 2 fields:
// a []*Event and an error
type EventsResult struct {
	Events []*Event
	Err    error
}

func (res *EventsResult) Error() string {
	return res.Err.Error()
}

// TODO this is going to be used to load a new object
type eventsLoader struct {
	nodes   map[string]*Event
	errs    map[string]error
	results []*Event
	m       sync.Mutex
}

func (res *eventsLoader) GetNewInstance() ent.DBObject {
	var event Event
	return &event
}

func (res *eventsLoader) GetConfig() ent.Config {
	return &configs.EventConfig{}
}

func (res *eventsLoader) SetPrivacyResult(id string, obj ent.DBObject, err error) {
	res.m.Lock()
	defer res.m.Unlock()
	if err != nil {
		res.errs[id] = err
	} else if obj != nil {
		// TODO kill results?
		ent := obj.(*Event)
		res.nodes[id] = ent
		res.results = append(res.results, ent)
	}
}

// TODO???
func (res *eventsLoader) List() []*Event {
	return res.results
}

func NewEventsLoader() *eventsLoader {
	return &eventsLoader{
		nodes: make(map[string]*Event),
		errs:  make(map[string]error),
	}
}

// IsNode is needed by gqlgen to indicate that this implements the Node interface in GraphQL
func (event Event) IsNode() {}

// GetType returns the NodeType of this entity. In this case: ContactType
func (event *Event) GetType() ent.NodeType {
	return EventType
}

// GetViewer returns the viewer for this entity.
func (event *Event) GetViewer() viewer.ViewerContext {
	return event.Viewer
}

// GetConfig returns the config for this entity.
func (event *Event) GetConfig() ent.Config {
	return &configs.EventConfig{}
}

// LoadEventFromContext loads the given Event given the context and id
func LoadEventFromContext(ctx context.Context, id string) (*Event, error) {
	v, err := viewer.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	return LoadEvent(v, id)
}

// GenLoadEventFromContext loads the given Event given the context and id
func GenLoadEventFromContext(ctx context.Context, id string) <-chan *EventResult {
	res := make(chan *EventResult)
	go func() {
		v, err := viewer.ForContext(ctx)
		if err != nil {
			res <- &EventResult{
				Err: err,
			}
			return
		}
		res <- <-(GenLoadEvent(v, id))
	}()
	return res
}

// LoadEvent loads the given Event given the viewer and id
func LoadEvent(v viewer.ViewerContext, id string) (*Event, error) {
	var event Event
	err := ent.LoadNode(v, id, &event)
	return &event, err
}

// GenLoadEvent loads the given Event given the id
func GenLoadEvent(v viewer.ViewerContext, id string) <-chan *EventResult {
	res := make(chan *EventResult)
	go func() {
		var result EventResult
		var event Event
		result.Err = <-ent.GenLoadNode(v, id, &event)
		result.Event = &event
		res <- &result
	}()
	return res
}

// LoadEvents loads multiple Events given the ids
func LoadEvents(v viewer.ViewerContext, ids ...string) ([]*Event, error) {
	loader := NewEventsLoader()
	err := ent.LoadNodes(v, ids, loader)
	return loader.results, err
}

// GenLoadEvents loads multiple Events given the ids
func GenLoadEvents(v viewer.ViewerContext, ids ...string) <-chan *EventsResult {
	res := make(chan *EventsResult)
	go func() {
		loader := NewEventsLoader()
		var result EventsResult
		result.Err = <-ent.GenLoadNodes(v, ids, loader)
		result.Events = loader.results
		res <- &result
	}()
	return res
}

// GenUser returns the User associated with the Event instance
func (event *Event) GenUser() <-chan *UserResult {
	return GenLoadUser(event.Viewer, event.UserID)
}

// LoadUser returns the User associated with the Event instance
func (event *Event) LoadUser() (*User, error) {
	return LoadUser(event.Viewer, event.UserID)
}

// LoadHostsEdges returns the Hosts edges associated with the Event instance
func (event *Event) LoadHostsEdges() ([]*ent.AssocEdge, error) {
	return ent.LoadEdgesByType(event.ID, EventToHostsEdge)
}

// GenHostsEdges returns the User edges associated with the Event instance
func (event *Event) GenHostsEdges() <-chan *ent.AssocEdgesResult {
	return ent.GenLoadEdgesByType(event.ID, EventToHostsEdge)
}

// GenHosts returns the Users associated with the Event instance
func (event *Event) GenHosts() <-chan *UsersResult {
	res := make(chan *UsersResult)
	go func() {
		loader := NewUsersLoader()
		var result UsersResult
		result.Err = <-ent.GenLoadNodesByType(event.Viewer, event.ID, EventToHostsEdge, loader)
		result.Users = loader.results
		res <- &result
	}()
	return res
}

// LoadHosts returns the Users associated with the Event instance
func (event *Event) LoadHosts() ([]*User, error) {
	loader := NewUsersLoader()
	err := ent.LoadNodesByType(event.Viewer, event.ID, EventToHostsEdge, loader)
	return loader.results, err
}

// LoadHostEdgeFor loads the ent.AssocEdge between the current node and the given id2 for the Hosts edge.
func (event *Event) LoadHostEdgeFor(id2 string) (*ent.AssocEdge, error) {
	return ent.LoadEdgeByType(event.ID, id2, EventToHostsEdge)
}

// GenHostEdgeFor provides a concurrent API to load the ent.AssocEdge between the current node and the given id2 for the Hosts edge.
func (event *Event) GenLoadHostEdgeFor(id2 string) <-chan *ent.AssocEdgeResult {
	return ent.GenLoadEdgeByType(event.ID, id2, EventToHostsEdge)
}

// LoadCreatorEdge returns the Creator edge associated with the Event instance
func (event *Event) LoadCreatorEdge() (*ent.AssocEdge, error) {
	return ent.LoadUniqueEdgeByType(event.ID, EventToCreatorEdge)
}

// GenCreatorEdge returns the Creator edge associated with the Event instance
func (event *Event) GenCreatorEdge() <-chan *ent.AssocEdgeResult {
	return ent.GenLoadUniqueEdgeByType(event.ID, EventToCreatorEdge)
}

// GenCreator returns the User associated with the Event instance
func (event *Event) GenCreator() <-chan *UserResult {
	res := make(chan *UserResult)
	go func() {
		var result UserResult
		var user User
		result.Err = <-ent.GenLoadUniqueNodeByType(event.Viewer, event.ID, EventToCreatorEdge, &user)
		result.User = &user
		res <- &result
	}()
	return res
}

// LoadCreator returns the User associated with the Event instance
func (event *Event) LoadCreator() (*User, error) {
	var user User
	err := ent.LoadUniqueNodeByType(event.Viewer, event.ID, EventToCreatorEdge, &user)
	return &user, err
}

// LoadCreatorEdgeFor loads the ent.AssocEdge between the current node and the given id2 for the Creator edge.
func (event *Event) LoadCreatorEdgeFor(id2 string) (*ent.AssocEdge, error) {
	return ent.LoadEdgeByType(event.ID, id2, EventToCreatorEdge)
}

// GenCreatorEdgeFor provides a concurrent API to load the ent.AssocEdge between the current node and the given id2 for the Creator edge.
func (event *Event) GenLoadCreatorEdgeFor(id2 string) <-chan *ent.AssocEdgeResult {
	return ent.GenLoadEdgeByType(event.ID, id2, EventToCreatorEdge)
}

// LoadInvitedEdges returns the Invited edges associated with the Event instance
func (event *Event) LoadInvitedEdges() ([]*ent.AssocEdge, error) {
	return ent.LoadEdgesByType(event.ID, EventToInvitedEdge)
}

// GenInvitedEdges returns the User edges associated with the Event instance
func (event *Event) GenInvitedEdges() <-chan *ent.AssocEdgesResult {
	return ent.GenLoadEdgesByType(event.ID, EventToInvitedEdge)
}

// GenInvited returns the Users associated with the Event instance
func (event *Event) GenInvited() <-chan *UsersResult {
	res := make(chan *UsersResult)
	go func() {
		loader := NewUsersLoader()
		var result UsersResult
		result.Err = <-ent.GenLoadNodesByType(event.Viewer, event.ID, EventToInvitedEdge, loader)
		result.Users = loader.results
		res <- &result
	}()
	return res
}

// LoadInvited returns the Users associated with the Event instance
func (event *Event) LoadInvited() ([]*User, error) {
	loader := NewUsersLoader()
	err := ent.LoadNodesByType(event.Viewer, event.ID, EventToInvitedEdge, loader)
	return loader.results, err
}

// LoadInvitedEdgeFor loads the ent.AssocEdge between the current node and the given id2 for the Invited edge.
func (event *Event) LoadInvitedEdgeFor(id2 string) (*ent.AssocEdge, error) {
	return ent.LoadEdgeByType(event.ID, id2, EventToInvitedEdge)
}

// GenInvitedEdgeFor provides a concurrent API to load the ent.AssocEdge between the current node and the given id2 for the Invited edge.
func (event *Event) GenLoadInvitedEdgeFor(id2 string) <-chan *ent.AssocEdgeResult {
	return ent.GenLoadEdgeByType(event.ID, id2, EventToInvitedEdge)
}

// LoadAttendingEdges returns the Attending edges associated with the Event instance
func (event *Event) LoadAttendingEdges() ([]*ent.AssocEdge, error) {
	return ent.LoadEdgesByType(event.ID, EventToAttendingEdge)
}

// GenAttendingEdges returns the User edges associated with the Event instance
func (event *Event) GenAttendingEdges() <-chan *ent.AssocEdgesResult {
	return ent.GenLoadEdgesByType(event.ID, EventToAttendingEdge)
}

// GenAttending returns the Users associated with the Event instance
func (event *Event) GenAttending() <-chan *UsersResult {
	res := make(chan *UsersResult)
	go func() {
		loader := NewUsersLoader()
		var result UsersResult
		result.Err = <-ent.GenLoadNodesByType(event.Viewer, event.ID, EventToAttendingEdge, loader)
		result.Users = loader.results
		res <- &result
	}()
	return res
}

// LoadAttending returns the Users associated with the Event instance
func (event *Event) LoadAttending() ([]*User, error) {
	loader := NewUsersLoader()
	err := ent.LoadNodesByType(event.Viewer, event.ID, EventToAttendingEdge, loader)
	return loader.results, err
}

// LoadAttendingEdgeFor loads the ent.AssocEdge between the current node and the given id2 for the Attending edge.
func (event *Event) LoadAttendingEdgeFor(id2 string) (*ent.AssocEdge, error) {
	return ent.LoadEdgeByType(event.ID, id2, EventToAttendingEdge)
}

// GenAttendingEdgeFor provides a concurrent API to load the ent.AssocEdge between the current node and the given id2 for the Attending edge.
func (event *Event) GenLoadAttendingEdgeFor(id2 string) <-chan *ent.AssocEdgeResult {
	return ent.GenLoadEdgeByType(event.ID, id2, EventToAttendingEdge)
}

// LoadDeclinedEdges returns the Declined edges associated with the Event instance
func (event *Event) LoadDeclinedEdges() ([]*ent.AssocEdge, error) {
	return ent.LoadEdgesByType(event.ID, EventToDeclinedEdge)
}

// GenDeclinedEdges returns the User edges associated with the Event instance
func (event *Event) GenDeclinedEdges() <-chan *ent.AssocEdgesResult {
	return ent.GenLoadEdgesByType(event.ID, EventToDeclinedEdge)
}

// GenDeclined returns the Users associated with the Event instance
func (event *Event) GenDeclined() <-chan *UsersResult {
	res := make(chan *UsersResult)
	go func() {
		loader := NewUsersLoader()
		var result UsersResult
		result.Err = <-ent.GenLoadNodesByType(event.Viewer, event.ID, EventToDeclinedEdge, loader)
		result.Users = loader.results
		res <- &result
	}()
	return res
}

// LoadDeclined returns the Users associated with the Event instance
func (event *Event) LoadDeclined() ([]*User, error) {
	loader := NewUsersLoader()
	err := ent.LoadNodesByType(event.Viewer, event.ID, EventToDeclinedEdge, loader)
	return loader.results, err
}

// LoadDeclinedEdgeFor loads the ent.AssocEdge between the current node and the given id2 for the Declined edge.
func (event *Event) LoadDeclinedEdgeFor(id2 string) (*ent.AssocEdge, error) {
	return ent.LoadEdgeByType(event.ID, id2, EventToDeclinedEdge)
}

// GenDeclinedEdgeFor provides a concurrent API to load the ent.AssocEdge between the current node and the given id2 for the Declined edge.
func (event *Event) GenLoadDeclinedEdgeFor(id2 string) <-chan *ent.AssocEdgeResult {
	return ent.GenLoadEdgeByType(event.ID, id2, EventToDeclinedEdge)
}

func (event *Event) ViewerRsvpStatus() (*EventRsvpStatus, error) {
	if !viewer.HasIdentity(event.Viewer) {
		ret := EventUnknown
		return &ret, nil
	}
	statusMap := event.RsvpStatusMap()
	edges := make(map[string]*ent.AssocEdge)
	errs := make(map[string]error)
	for key, data := range statusMap {
		// TODO concurrent versions
		edges[key], errs[key] = ent.LoadEdgeByType(event.ID, event.Viewer.GetViewerID(), data.Edge)
	}
	for _, err := range errs {
		if err != nil {
			return nil, err
		}
	}
	var ret EventRsvpStatus
	for key, edge := range edges {
		// TODO better zero value behavior at some point
		if edge != nil && edge.ID1 != "" {
			var ok bool
			ret, ok = statusMap[key].ConstName.(EventRsvpStatus)
			if !ok {
				return nil, errors.New("error casting constant to EventRsvpStatus")
			}
			break
		}
	}
	return &ret, nil
}

func (event *Event) ViewerRsvpStatusForGQL() (*string, error) {
	enum, err := event.ViewerRsvpStatus()
	if err != nil {
		return nil, err
	}
	str := string(*enum)
	return &str, nil
}

func (event *Event) RsvpStatusMap() ent.AssocStatusMap {
	return ent.AssocStatusMap{
		"event_attending": &ent.AssociationEdgeGroupStatusInfo{
			EdgeName:          "Attending",
			Edge:              EventToAttendingEdge,
			ConstName:         EventAttending,
			UseInStatusAction: true,
		},
		"event_declined": &ent.AssociationEdgeGroupStatusInfo{
			EdgeName:          "Declined",
			Edge:              EventToDeclinedEdge,
			ConstName:         EventDeclined,
			UseInStatusAction: true,
		},
		"event_invited": &ent.AssociationEdgeGroupStatusInfo{
			EdgeName:          "Invited",
			Edge:              EventToInvitedEdge,
			ConstName:         EventInvited,
			UseInStatusAction: false,
		},
	}
}

// DBFields is used by the ent framework to load the ent from the underlying database
func (event *Event) DBFields() ent.DBFields {
	return ent.DBFields{
		"id": func(v interface{}) error {
			var err error
			event.ID, err = cast.ToUUIDString(v)
			return err
		},
		"name": func(v interface{}) error {
			var err error
			event.Name, err = cast.ToString(v)
			return err
		},
		"user_id": func(v interface{}) error {
			var err error
			event.UserID, err = cast.ToString(v)
			return err
		},
		"start_time": func(v interface{}) error {
			var err error
			event.StartTime, err = cast.ToTime(v)
			return err
		},
		"end_time": func(v interface{}) error {
			var err error
			event.EndTime, err = cast.ToNullableTime(v)
			return err
		},
		"location": func(v interface{}) error {
			var err error
			event.Location, err = cast.ToString(v)
			return err
		},
	}
}

var _ ent.Entity = &Event{}
