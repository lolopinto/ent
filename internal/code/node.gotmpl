// Code generated by github.com/lolopinto/ent/ent, DO NOT edit. 

package models

{{with .CodePath -}}
import (
  "context"
  "errors"
  "strings"
  "sync"

	"github.com/google/uuid"

  "github.com/lolopinto/ent/ent"
  "github.com/lolopinto/ent/ent/cast"
  "github.com/lolopinto/ent/ent/privacy"
  "github.com/lolopinto/ent/ent/viewer"

  {{.PathToConfigs}}
)
{{end -}}

{{with .NodeData -}}
{{ $constGroup := .ConstantGroups -}}

{{with .GetSortedConstantGroups -}}

{{ range . -}}
  {{if .CreateNewType -}}
  type {{.ConstType}} string
  {{end -}}
{{end -}}

const (
  {{ range . -}}
    {{$constType := .ConstType -}}
    {{range .GetSortedConstants -}}
      // {{.Comment}}
      {{.ConstName}} {{$constType}} = {{.ConstValue}}
    {{end}}

  {{end -}}
)
{{end -}}

// {{.Node}} represents the `{{.Node}}` model 
type {{.Node}} struct {
  ent.Node
  {{/* TODO, this needs to be configurable but this is fine for now */ -}}
  privacy.AlwaysDenyPrivacyPolicy
  {{ range $field := .FieldInfo.Fields -}} 
    {{if $field.TopLevelStructField -}}
      {{$field.FieldName}} {{fTypeString $field}} {{$field.FieldTag}}
    {{end -}}
  {{end -}}
  Viewer viewer.ViewerContext
}


// {{.NodeResult}} stores the result of loading a {{.Node}}. It's a tuple type which has 2 fields: 
// a {{.Node}} and an error
type {{.NodeResult}} struct {
  {{.Node}} *{{.Node}}
  Error error
}

// {{.NodesResult}} stores the result of loading a slice of {{.Node}}s. It's a tuple type which has 2 fields: 
// a {{.NodesSlice}} and an error
type {{.NodesResult}} struct {
  {{.Nodes}} {{.NodesSlice}}
  Error error
}

// IsNode is needed by gqlgen to indicate that this implements the Node interface in GraphQL
func ({{.NodeInstance}} {{.Node}}) IsNode() {}

// GetType returns the NodeType of this entity. In this case: ContactType
func ({{.NodeInstance}} *{{.Node}}) GetType() ent.NodeType {
	return {{.NodeType}}
}

// GetViewer returns the viewer for this entity.
func ({{.NodeInstance}} *{{.Node}}) GetViewer() viewer.ViewerContext {
  return {{.NodeInstance}}.Viewer
}

// Load{{.Node}}FromContext loads the given {{.Node}} given the context and id
func Load{{.Node}}FromContext(ctx context.Context, id string) (*{{.Node}}, error) {
  v, err := viewer.ForContext(ctx)
  if err != nil {
    return nil, err
  }
	return Load{{.Node}}(v, id)
}

// Load{{.Node}} loads the given {{.Node}} given the viewer and id
func Load{{.Node}}(v viewer.ViewerContext, id string) (*{{.Node}}, error) {
  var {{.NodeInstance}} {{.Node}}
  err := ent.LoadNode(v, id, &{{.NodeInstance}}, {{.EntConfig}})
  return &{{.NodeInstance}}, err
}

// GenLoad{{.Node}} loads the given {{.Node}} given the id
func GenLoad{{.Node}}(v viewer.ViewerContext, id string, result *{{.NodeResult}}, wg *sync.WaitGroup) {
  defer wg.Done()
  var {{.NodeInstance}} {{.Node}}
  chanErr := make(chan error)
  go ent.GenLoadNode(v, id, &{{.NodeInstance}}, {{.EntConfig}}, chanErr)
  err := <-chanErr
  result.{{.Node}} = &{{.NodeInstance}}
  result.Error = err
}

{{/* todo: deal with importing right packages above and circular dependency all that jazz*/}}
{{/* this should be user/factory. user/config? user/query user/privacy etc. */}}
{{with . -}}
  {{$currentNodeInstance := .NodeInstance}}
  {{$currentNode := .Node}}
  {{$currentPackageName := .PackageName}}
  {{with .EdgeInfo}}
    {{range $edge := .FieldEdges -}}
      {{$edgeName := .EdgeName -}}
      {{with .NodeInfo -}}
        // Gen{{$edgeName}} returns the {{$edgeName}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}(result *{{.NodeResult}}, wg *sync.WaitGroup) {
          go GenLoad{{.Node}}({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.{{$edge.FieldName}}, result, wg )
        }

        // Load{{$edgeName}} returns the {{$edgeName}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}() (*{{.Node}}, error) {
          return Load{{.Node}}({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.{{$edge.FieldName}})
        }
      {{end}}
    {{end}}
    {{range $edge := .ForeignKeys -}}
      {{$edgeName := .EdgeName -}}
      {{with .NodeInfo -}}
        // Gen{{$edgeName}} returns the {{.Nodes}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}(result *{{.NodesResult}}, wg *sync.WaitGroup) {
          defer wg.Done()
          var {{.NodeInstance}}s {{.NodesSlice}}
          chanErr := make(chan error)
          go ent.GenLoadForeignKeyNodes({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, &{{.NodeInstance}}s, "{{$currentPackageName}}_id", {{.EntConfig}}, chanErr)
          err := <-chanErr
          result.{{.Nodes}} = {{.NodeInstance}}s
          result.Error = err
        }

        // Load{{$edgeName}} returns the {{.Nodes}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}() ({{.NodesSlice}}, error) {
          var {{.NodeInstance}}s {{.NodesSlice}}
          err := ent.LoadForeignKeyNodes({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, &{{.NodeInstance}}s, "{{$currentPackageName}}_id", {{.EntConfig}})
          return {{.NodeInstance}}s, err
        }
      {{end}}
    {{end}}
    {{range $edge := .Associations -}}
      {{$edgeName := .EdgeName -}}
      {{$uniqueEdge := .Unique}}
      {{with .NodeInfo -}}

        {{ if $uniqueEdge -}}
          // Load{{$edgeName}}Edge returns the {{$edgeName}} edge associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}Edge() (*ent.AssocEdge, error) {
            return ent.LoadUniqueEdgeByType({{$currentNodeInstance}}.ID, {{$edge.EdgeConst}})
          }

          // Gen{{$edgeName}}Edge returns the {{$edgeName}} edge associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}Edge(result *ent.AssocEdgeResult, wg *sync.WaitGroup) {
            defer wg.Done()
            edgeResultChan := make(chan ent.AssocEdgeResult)
            go ent.GenLoadUniqueEdgeByType({{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, edgeResultChan)
            *result = <- edgeResultChan
          }

          // Gen{{$edgeName}} returns the {{.Node}} associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}(result *{{.NodeResult}}, wg *sync.WaitGroup) {
            defer wg.Done()
            var {{.NodeInstance}} {{.Node}}
            chanErr := make(chan error)
            go ent.GenLoadUniqueNodeByType({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, &{{.NodeInstance}}, {{.EntConfig}}, chanErr)
            err := <-chanErr
            result.{{.Node}} = &{{.NodeInstance}}
            result.Error = err
          }

          // Load{{$edgeName}} returns the {{.Node}} associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}() (*{{.Node}}, error) {
            var {{.NodeInstance}} {{.Node}}
            err := ent.LoadUniqueNodeByType({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, &{{.NodeInstance}}, {{.EntConfig}})
            return &{{.NodeInstance}}, err
          }
        {{else -}}
          // Load{{$edgeName}}Edges returns the {{$edgeName}} edges associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}Edges() ([]*ent.AssocEdge, error) {
            return ent.LoadEdgesByType({{$currentNodeInstance}}.ID, {{$edge.EdgeConst}})
          }

          // Gen{{$edgeName}}Edges returns the {{.Node}} edges associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}Edges(result *ent.AssocEdgesResult, wg *sync.WaitGroup) {
            defer wg.Done()
            edgesResultChan := make(chan ent.AssocEdgesResult)
            go ent.GenLoadEdgesByType({{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, edgesResultChan)
            *result = <- edgesResultChan
          }

          // Gen{{$edgeName}} returns the {{.Nodes}} associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}(result *{{.NodesResult}}, wg *sync.WaitGroup) {
            defer wg.Done()
            var {{.NodeInstance}}s {{.NodesSlice}}
            chanErr := make(chan error)
            go ent.GenLoadNodesByType({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, &{{.NodeInstance}}s, {{.EntConfig}}, chanErr)
            err := <-chanErr
            result.{{.Nodes}} = {{.NodeInstance}}s
            result.Error = err
          }

          // Load{{$edgeName}} returns the {{.Nodes}} associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}() ({{.NodesSlice}}, error) {
            var {{.NodeInstance}}s {{.NodesSlice}}
            err := ent.LoadNodesByType({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, &{{.NodeInstance}}s, {{.EntConfig}})
            return {{.NodeInstance}}s, err
          }
        {{end -}}


        // Load{{$edge.Singular}}EdgeFor loads the ent.AssocEdge between the current node and the given id2 for the {{$edgeName}} edge.
        func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edge.Singular}}EdgeFor(id2 string) (*ent.AssocEdge, error) {
          return ent.LoadEdgeByType({{$currentNodeInstance}}.ID, id2, {{$edge.EdgeConst}})
        }

        // Gen{{$edge.Singular}}EdgeFor provides a concurrent API to load the ent.AssocEdge between the current node and the given id2 for the {{$edgeName}} edge.
        func ({{$currentNodeInstance}} *{{$currentNode}}) GenLoad{{$edge.Singular}}EdgeFor(id2 string, result *ent.AssocEdgeResult, wg *sync.WaitGroup) {
          defer wg.Done()
          edgeResultChan := make(chan ent.AssocEdgeResult)
          go ent.GenLoadEdgeByType({{$currentNodeInstance}}.ID, id2, {{$edge.EdgeConst}}, edgeResultChan)
          *result = <- edgeResultChan
        }
      {{end}}
    {{end }}

    {{range $assocEdgeGroup := .AssocGroups -}}
      {{- $const := $assocEdgeGroup.ConstType -}}
      {{$funcName := $assocEdgeGroup.GetStatusFuncName -}}
      func ({{$currentNodeInstance}} *{{$currentNode}}) {{$funcName}}() (*{{$const}}, error) {
        if !viewer.HasIdentity({{$currentNodeInstance}}.Viewer) {
          ret := {{$assocEdgeGroup.GetConstNameForUnknown}}
      		return &ret, nil
        }
        statusMap := {{$currentNodeInstance}}.{{$assocEdgeGroup.GroupStatusName}}Map()
        edges := make(map[string]*ent.AssocEdge)
        errs := make(map[string]error)
        for key, data := range statusMap {
          // TODO concurrent versions
          edges[key], errs[key] = ent.LoadEdgeByType({{$currentNodeInstance}}.ID, {{$currentNodeInstance}}.Viewer.GetViewerID(), data.Edge)
        }
        for _, err := range errs {
          if err != nil {
            return nil, err
          }
        }
        var ret {{$const}}
        for key, edge := range edges {
          // TODO better zero value behavior at some point
      		if edge != nil && edge.ID1 != "" {
            var ok bool
            ret, ok = statusMap[key].ConstName.({{$const}})
            if !ok {
      				return nil, errors.New("error casting constant to {{$const}}")
      			}
            break
          }
        }
        return &ret, nil
      }

      func ({{$currentNodeInstance}} *{{$currentNode}}) {{$funcName}}ForGQL() (*string, error) {
        enum, err := {{$currentNodeInstance}}.{{$assocEdgeGroup.GetStatusFuncName}}()
        if err != nil {
          return nil, err
        }
        str := string(*enum)
        return &str, nil
      }

      func ({{$currentNodeInstance}} *{{$currentNode}}) {{$assocEdgeGroup.GroupStatusName}}Map() ent.AssocStatusMap {
        {{ $constInfo := index $constGroup $const -}}
        return ent.AssocStatusMap {
        {{ range $assocEdge := $assocEdgeGroup.Edges -}}
          {{ $edgeName := $assocEdge.EdgeName -}}
          {{ $constName := $assocEdgeGroup.GetConstNameForEdgeName $edgeName -}}
          {{ $constInfo := index $constInfo.Constants $constName -}}
          {{ $constInfo.ConstValue}}: &ent.AssociationEdgeGroupStatusInfo{
            EdgeName: "{{$edgeName}}",
            Edge: {{$assocEdge.EdgeConst}},
            ConstName: {{$constName}},
            {{ if $assocEdgeGroup.UseEdgeInStatusAction $edgeName -}}
              UseInStatusAction: true,
            {{ else -}}
              UseInStatusAction: false,
            {{ end -}}
          },
        {{ end -}}
        }
      }
    {{ end -}}
  {{end}}

// DBFields is used by the ent framework to load the ent from the underlying database
func ({{$currentNodeInstance}} *{{$currentNode}}) DBFields() ent.DBFields {
  return ent.DBFields {
    "id": func(v interface{}) error {
      var err error
      {{$currentNodeInstance}}.ID, err = cast.ToUUIDString(v)
      return err
    },
    {{ range $field := .FieldInfo.Fields -}}
      {{if $field.TopLevelStructField -}}
        "{{$field.GetDbColName}}": func(v interface{}) error {
          var err error
          {{$currentNodeInstance}}.{{$field.FieldName}}, err = {{$field.GetCastToMethod}}(v)
          return err
        },
      {{end -}}
    {{end -}}
  }
}

{{end}}

var _ ent.Entity = &{{.Node}}{}

{{end -}}
